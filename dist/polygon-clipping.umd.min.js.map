{"version":3,"file":"polygon-clipping.umd.min.js","sources":["../src/bbox.js","../src/flp.js","../src/rounder.js","../src/vector.js","../src/sweep-event.js","../src/segment.js","../src/geom-in.js","../src/geom-out.js","../src/sweep-line.js","../src/operation.js","../src/index.js"],"sourcesContent":["/**\n * A bounding box has the format:\n *\n *  { ll: { x: xmin, y: ymin }, ur: { x: xmax, y: ymax } }\n *\n */\n\nexport const isInBbox = (bbox, point) => {\n  return (\n    bbox.ll.x <= point.x &&\n    point.x <= bbox.ur.x &&\n    bbox.ll.y <= point.y &&\n    point.y <= bbox.ur.y\n  )\n}\n\n/* Returns either null, or a bbox (aka an ordered pair of points)\n * If there is only one point of overlap, a bbox with identical points\n * will be returned */\nexport const getBboxOverlap = (b1, b2) => {\n  // check if the bboxes overlap at all\n  if (\n    b2.ur.x < b1.ll.x ||\n    b1.ur.x < b2.ll.x ||\n    b2.ur.y < b1.ll.y ||\n    b1.ur.y < b2.ll.y\n  )\n    return null\n\n  // find the middle two X values\n  const lowerX = b1.ll.x < b2.ll.x ? b2.ll.x : b1.ll.x\n  const upperX = b1.ur.x < b2.ur.x ? b1.ur.x : b2.ur.x\n\n  // find the middle two Y values\n  const lowerY = b1.ll.y < b2.ll.y ? b2.ll.y : b1.ll.y\n  const upperY = b1.ur.y < b2.ur.y ? b1.ur.y : b2.ur.y\n\n  // put those middle values together to get the overlap\n  return { ll: { x: lowerX, y: lowerY }, ur: { x: upperX, y: upperY } }\n}\n","/* Javascript doesn't do integer math. Everything is\n * floating point with percision Number.EPSILON.\n *\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON\n */\n\nlet epsilon = Number.EPSILON\n\n// IE Polyfill\nif (epsilon === undefined) epsilon = Math.pow(2, -52)\n\n/**\n * Floating point comparator.\n * @param {Number} a - value\n * @param {Number} b - value\n * @returns {Number} 0 when value a and b are equal, -1 when value a < b, 1 when value a > b\n */\nexport const cmp = (a, b) => {\n  if (Math.abs(a - b) < epsilon) return 0\n  // normal comparison\n  return a < b ? -1 : 1\n}\n","import { cmp } from \"./flp\"\nimport SplayTree from \"splaytree\"\n\n/**\n * This class rounds incoming values sufficiently so that\n * floating points problems are, for the most part, avoided.\n *\n * Incoming points are have their x & y values tested against\n * all previously seen x & y values. If either is 'too close'\n * to a previously seen value, it's value is 'snapped' to the\n * previously seen value.\n *\n * All points should be rounded by this class before being\n * stored in any data structures in the rest of this algorithm.\n */\n\nclass PtRounder {\n  constructor() {\n    this.reset()\n  }\n\n  reset() {\n    this.xRounder = new CoordRounder()\n    this.yRounder = new CoordRounder()\n  }\n\n  round(x, y) {\n    return {\n      x: this.xRounder.round(x),\n      y: this.yRounder.round(y),\n    }\n  }\n}\n\nclass CoordRounder {\n  constructor() {\n    this.tree = new SplayTree(cmp)\n    // preseed with 0 so we don't end up with values < Number.EPSILON\n    this.round(0)\n  }\n\n  // Note: this can rounds input values backwards or forwards.\n  //       You might ask, why not restrict this to just rounding\n  //       forwards? Wouldn't that allow left endpoints to always\n  //       remain left endpoints during splitting (never change to\n  //       right). No - it wouldn't, because we snap intersections\n  //       to endpoints (to establish independence from the segment\n  //       angle for t-intersections).\n  round(coord) {\n    const node = this.tree.add(coord)\n    return node.key\n  }\n}\n\n// singleton available by import\nconst rounder = new PtRounder()\n\nexport default rounder\n","import { orient2d } from \"robust-predicates/umd/orient2d\"\n\n/* Cross Product of two vectors with first point at origin */\nexport const crossProduct = (a, b) => a.x * b.y - a.y * b.x\n\n/* Dot Product of two vectors with first point at origin */\nexport const dotProduct = (a, b) => a.x * b.x + a.y * b.y\n\n/* Comparator for two vectors with same starting point */\nexport const compareVectorAngles = (basePt, endPt1, endPt2) => {\n  const res = orient2d(\n    basePt.x,\n    basePt.y,\n    endPt1.x,\n    endPt1.y,\n    endPt2.x,\n    endPt2.y,\n  )\n  if (res > 0) return -1\n  if (res < 0) return 1\n  return 0\n}\n\nexport const length = (v) => Math.sqrt(dotProduct(v, v))\n\n/* Get the sine of the angle from pShared -> pAngle to pShaed -> pBase */\nexport const sineOfAngle = (pShared, pBase, pAngle) => {\n  const vBase = { x: pBase.x - pShared.x, y: pBase.y - pShared.y }\n  const vAngle = { x: pAngle.x - pShared.x, y: pAngle.y - pShared.y }\n  return crossProduct(vAngle, vBase) / length(vAngle) / length(vBase)\n}\n\n/* Get the cosine of the angle from pShared -> pAngle to pShaed -> pBase */\nexport const cosineOfAngle = (pShared, pBase, pAngle) => {\n  const vBase = { x: pBase.x - pShared.x, y: pBase.y - pShared.y }\n  const vAngle = { x: pAngle.x - pShared.x, y: pAngle.y - pShared.y }\n  return dotProduct(vAngle, vBase) / length(vAngle) / length(vBase)\n}\n\n/* Get the closest point on an line (defined by two points)\n * to another point. */\nexport const closestPoint = (ptA1, ptA2, ptB) => {\n  if (ptA1.x === ptA2.x) return { x: ptA1.x, y: ptB.y } // vertical vector\n  if (ptA1.y === ptA2.y) return { x: ptB.x, y: ptA1.y } // horizontal vector\n\n  // determinne which point is further away\n  // we use the further point as our base in the calculation, so that the\n  // vectors are more parallel, providing more accurate dot product\n  const v1 = { x: ptB.x - ptA1.x, y: ptB.y - ptA1.y }\n  const v2 = { x: ptB.x - ptA2.x, y: ptB.y - ptA2.y }\n  let vFar, vA, farPt\n  if (dotProduct(v1, v1) > dotProduct(v2, v2)) {\n    vFar = v1\n    vA = { x: ptA2.x - ptA1.x, y: ptA2.y - ptA1.y }\n    farPt = ptA1\n  } else {\n    vFar = v2\n    vA = { x: ptA1.x - ptA2.x, y: ptA1.y - ptA2.y }\n    farPt = ptA2\n  }\n\n  // manually test if the current point can be considered to be on the line\n  // If the X coordinate was on the line, would the Y coordinate be as well?\n  const xDist = (ptB.x - farPt.x) / vA.x\n  if (ptB.y === farPt.y + xDist * vA.y) return ptB\n\n  // If the Y coordinate was on the line, would the X coordinate be as well?\n  const yDist = (ptB.y - farPt.y) / vA.y\n  if (ptB.x === farPt.x + yDist * vA.x) return ptB\n\n  // current point isn't exactly on line, so return closest point\n  const dist = dotProduct(vA, vFar) / dotProduct(vA, vA)\n  return { x: farPt.x + dist * vA.x, y: farPt.y + dist * vA.y }\n}\n\n/* Get the x coordinate where the given line (defined by a point and vector)\n * crosses the horizontal line with the given y coordiante.\n * In the case of parrallel lines (including overlapping ones) returns null. */\nexport const horizontalIntersection = (pt, v, y) => {\n  if (v.y === 0) return null\n  return { x: pt.x + (v.x / v.y) * (y - pt.y), y: y }\n}\n\n/* Get the y coordinate where the given line (defined by a point and vector)\n * crosses the vertical line with the given x coordiante.\n * In the case of parrallel lines (including overlapping ones) returns null. */\nexport const verticalIntersection = (pt, v, x) => {\n  if (v.x === 0) return null\n  return { x: x, y: pt.y + (v.y / v.x) * (x - pt.x) }\n}\n\n/* Get the intersection of two lines, each defined by a base point and a vector.\n * In the case of parrallel lines (including overlapping ones) returns null. */\nexport const intersection = (pt1, v1, pt2, v2) => {\n  // take some shortcuts for vertical and horizontal lines\n  // this also ensures we don't calculate an intersection and then discover\n  // it's actually outside the bounding box of the line\n  if (v1.x === 0) return verticalIntersection(pt2, v2, pt1.x)\n  if (v2.x === 0) return verticalIntersection(pt1, v1, pt2.x)\n  if (v1.y === 0) return horizontalIntersection(pt2, v2, pt1.y)\n  if (v2.y === 0) return horizontalIntersection(pt1, v1, pt2.y)\n\n  // General case for non-overlapping segments.\n  // This algorithm is based on Schneider and Eberly.\n  // http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf - pg 244\n\n  const kross = crossProduct(v1, v2)\n  if (kross == 0) return null\n\n  const ve = { x: pt2.x - pt1.x, y: pt2.y - pt1.y }\n  const d1 = crossProduct(ve, v1) / kross\n  const d2 = crossProduct(ve, v2) / kross\n\n  // take the average of the two calculations to minimize rounding error\n  const x1 = pt1.x + d2 * v1.x,\n    x2 = pt2.x + d1 * v2.x\n  const y1 = pt1.y + d2 * v1.y,\n    y2 = pt2.y + d1 * v2.y\n  const x = (x1 + x2) / 2\n  const y = (y1 + y2) / 2\n  return { x: x, y: y }\n}\n\n/* Given a vector, return one that is perpendicular */\nexport const perpendicular = (v) => {\n  return { x: -v.y, y: v.x }\n}\n","import Segment from \"./segment\"\nimport { cosineOfAngle, sineOfAngle } from \"./vector\"\n\nexport default class SweepEvent {\n  // for ordering sweep events in the sweep event queue\n  static compare(a, b) {\n    // favor event with a point that the sweep line hits first\n    const ptCmp = SweepEvent.comparePoints(a.point, b.point)\n    if (ptCmp !== 0) return ptCmp\n\n    // the points are the same, so link them if needed\n    if (a.point !== b.point) a.link(b)\n\n    // favor right events over left\n    if (a.isLeft !== b.isLeft) return a.isLeft ? 1 : -1\n\n    // we have two matching left or right endpoints\n    // ordering of this case is the same as for their segments\n    return Segment.compare(a.segment, b.segment)\n  }\n\n  // for ordering points in sweep line order\n  static comparePoints(aPt, bPt) {\n    if (aPt.x < bPt.x) return -1\n    if (aPt.x > bPt.x) return 1\n\n    if (aPt.y < bPt.y) return -1\n    if (aPt.y > bPt.y) return 1\n\n    return 0\n  }\n\n  // Warning: 'point' input will be modified and re-used (for performance)\n  constructor(point, isLeft) {\n    if (point.events === undefined) point.events = [this]\n    else point.events.push(this)\n    this.point = point\n    this.isLeft = isLeft\n    // this.segment, this.otherSE set by factory\n  }\n\n  link(other) {\n    if (other.point === this.point) {\n      throw new Error(\"Tried to link already linked events\")\n    }\n    const otherEvents = other.point.events\n    for (let i = 0, iMax = otherEvents.length; i < iMax; i++) {\n      const evt = otherEvents[i]\n      this.point.events.push(evt)\n      evt.point = this.point\n    }\n    this.checkForConsuming()\n  }\n\n  /* Do a pass over our linked events and check to see if any pair\n   * of segments match, and should be consumed. */\n  checkForConsuming() {\n    // FIXME: The loops in this method run O(n^2) => no good.\n    //        Maintain little ordered sweep event trees?\n    //        Can we maintaining an ordering that avoids the need\n    //        for the re-sorting with getLeftmostComparator in geom-out?\n\n    // Compare each pair of events to see if other events also match\n    const numEvents = this.point.events.length\n    for (let i = 0; i < numEvents; i++) {\n      const evt1 = this.point.events[i]\n      if (evt1.segment.consumedBy !== undefined) continue\n      for (let j = i + 1; j < numEvents; j++) {\n        const evt2 = this.point.events[j]\n        if (evt2.consumedBy !== undefined) continue\n        if (evt1.otherSE.point.events !== evt2.otherSE.point.events) continue\n        evt1.segment.consume(evt2.segment)\n      }\n    }\n  }\n\n  getAvailableLinkedEvents() {\n    // point.events is always of length 2 or greater\n    const events = []\n    for (let i = 0, iMax = this.point.events.length; i < iMax; i++) {\n      const evt = this.point.events[i]\n      if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {\n        events.push(evt)\n      }\n    }\n    return events\n  }\n\n  /**\n   * Returns a comparator function for sorting linked events that will\n   * favor the event that will give us the smallest left-side angle.\n   * All ring construction starts as low as possible heading to the right,\n   * so by always turning left as sharp as possible we'll get polygons\n   * without uncessary loops & holes.\n   *\n   * The comparator function has a compute cache such that it avoids\n   * re-computing already-computed values.\n   */\n  getLeftmostComparator(baseEvent) {\n    const cache = new Map()\n\n    const fillCache = (linkedEvent) => {\n      const nextEvent = linkedEvent.otherSE\n      cache.set(linkedEvent, {\n        sine: sineOfAngle(this.point, baseEvent.point, nextEvent.point),\n        cosine: cosineOfAngle(this.point, baseEvent.point, nextEvent.point),\n      })\n    }\n\n    return (a, b) => {\n      if (!cache.has(a)) fillCache(a)\n      if (!cache.has(b)) fillCache(b)\n\n      const { sine: asine, cosine: acosine } = cache.get(a)\n      const { sine: bsine, cosine: bcosine } = cache.get(b)\n\n      // both on or above x-axis\n      if (asine >= 0 && bsine >= 0) {\n        if (acosine < bcosine) return 1\n        if (acosine > bcosine) return -1\n        return 0\n      }\n\n      // both below x-axis\n      if (asine < 0 && bsine < 0) {\n        if (acosine < bcosine) return -1\n        if (acosine > bcosine) return 1\n        return 0\n      }\n\n      // one above x-axis, one below\n      if (bsine < asine) return -1\n      if (bsine > asine) return 1\n      return 0\n    }\n  }\n}\n","import operation from \"./operation\"\nimport SweepEvent from \"./sweep-event\"\nimport { isInBbox, getBboxOverlap } from \"./bbox\"\nimport { intersection } from \"./vector\"\nimport rounder from \"./rounder\"\n\n// Give segments unique ID's to get consistent sorting of\n// segments and sweep events when all else is identical\nlet segmentId = 0\n\nexport default class Segment {\n  /* This compare() function is for ordering segments in the sweep\n   * line tree, and does so according to the following criteria:\n   *\n   * Consider the vertical line that lies an infinestimal step to the\n   * right of the right-more of the two left endpoints of the input\n   * segments. Imagine slowly moving a point up from negative infinity\n   * in the increasing y direction. Which of the two segments will that\n   * point intersect first? That segment comes 'before' the other one.\n   *\n   * If neither segment would be intersected by such a line, (if one\n   * or more of the segments are vertical) then the line to be considered\n   * is directly on the right-more of the two left inputs.\n   */\n  static compare(a, b) {\n    const alx = a.leftSE.point.x\n    const blx = b.leftSE.point.x\n    const arx = a.rightSE.point.x\n    const brx = b.rightSE.point.x\n\n    // check if they're even in the same vertical plane\n    if (brx < alx) return 1\n    if (arx < blx) return -1\n\n    const aly = a.leftSE.point.y\n    const bly = b.leftSE.point.y\n    const ary = a.rightSE.point.y\n    const bry = b.rightSE.point.y\n\n    // is left endpoint of segment B the right-more?\n    if (alx < blx) {\n      // are the two segments in the same horizontal plane?\n      if (bly < aly && bly < ary) return 1\n      if (bly > aly && bly > ary) return -1\n\n      // is the B left endpoint colinear to segment A?\n      const aCmpBLeft = a.comparePoint(b.leftSE.point)\n      if (aCmpBLeft < 0) return 1\n      if (aCmpBLeft > 0) return -1\n\n      // is the A right endpoint colinear to segment B ?\n      const bCmpARight = b.comparePoint(a.rightSE.point)\n      if (bCmpARight !== 0) return bCmpARight\n\n      // colinear segments, consider the one with left-more\n      // left endpoint to be first (arbitrary?)\n      return -1\n    }\n\n    // is left endpoint of segment A the right-more?\n    if (alx > blx) {\n      if (aly < bly && aly < bry) return -1\n      if (aly > bly && aly > bry) return 1\n\n      // is the A left endpoint colinear to segment B?\n      const bCmpALeft = b.comparePoint(a.leftSE.point)\n      if (bCmpALeft !== 0) return bCmpALeft\n\n      // is the B right endpoint colinear to segment A?\n      const aCmpBRight = a.comparePoint(b.rightSE.point)\n      if (aCmpBRight < 0) return 1\n      if (aCmpBRight > 0) return -1\n\n      // colinear segments, consider the one with left-more\n      // left endpoint to be first (arbitrary?)\n      return 1\n    }\n\n    // if we get here, the two left endpoints are in the same\n    // vertical plane, ie alx === blx\n\n    // consider the lower left-endpoint to come first\n    if (aly < bly) return -1\n    if (aly > bly) return 1\n\n    // left endpoints are identical\n    // check for colinearity by using the left-more right endpoint\n\n    // is the A right endpoint more left-more?\n    if (arx < brx) {\n      const bCmpARight = b.comparePoint(a.rightSE.point)\n      if (bCmpARight !== 0) return bCmpARight\n    }\n\n    // is the B right endpoint more left-more?\n    if (arx > brx) {\n      const aCmpBRight = a.comparePoint(b.rightSE.point)\n      if (aCmpBRight < 0) return 1\n      if (aCmpBRight > 0) return -1\n    }\n\n    if (arx !== brx) {\n      // are these two [almost] vertical segments with opposite orientation?\n      // if so, the one with the lower right endpoint comes first\n      const ay = ary - aly\n      const ax = arx - alx\n      const by = bry - bly\n      const bx = brx - blx\n      if (ay > ax && by < bx) return 1\n      if (ay < ax && by > bx) return -1\n    }\n\n    // we have colinear segments with matching orientation\n    // consider the one with more left-more right endpoint to be first\n    if (arx > brx) return 1\n    if (arx < brx) return -1\n\n    // if we get here, two two right endpoints are in the same\n    // vertical plane, ie arx === brx\n\n    // consider the lower right-endpoint to come first\n    if (ary < bry) return -1\n    if (ary > bry) return 1\n\n    // right endpoints identical as well, so the segments are idential\n    // fall back on creation order as consistent tie-breaker\n    if (a.id < b.id) return -1\n    if (a.id > b.id) return 1\n\n    // identical segment, ie a === b\n    return 0\n  }\n\n  /* Warning: a reference to ringWindings input will be stored,\n   *  and possibly will be later modified */\n  constructor(leftSE, rightSE, rings, windings) {\n    this.id = ++segmentId\n    this.leftSE = leftSE\n    leftSE.segment = this\n    leftSE.otherSE = rightSE\n    this.rightSE = rightSE\n    rightSE.segment = this\n    rightSE.otherSE = leftSE\n    this.rings = rings\n    this.windings = windings\n    // left unset for performance, set later in algorithm\n    // this.ringOut, this.consumedBy, this.prev\n  }\n\n  static fromRing(pt1, pt2, ring) {\n    let leftPt, rightPt, winding\n\n    // ordering the two points according to sweep line ordering\n    const cmpPts = SweepEvent.comparePoints(pt1, pt2)\n    if (cmpPts < 0) {\n      leftPt = pt1\n      rightPt = pt2\n      winding = 1\n    } else if (cmpPts > 0) {\n      leftPt = pt2\n      rightPt = pt1\n      winding = -1\n    } else\n      throw new Error(\n        `Tried to create degenerate segment at [${pt1.x}, ${pt1.y}]`,\n      )\n\n    const leftSE = new SweepEvent(leftPt, true)\n    const rightSE = new SweepEvent(rightPt, false)\n    return new Segment(leftSE, rightSE, [ring], [winding])\n  }\n\n  /* When a segment is split, the rightSE is replaced with a new sweep event */\n  replaceRightSE(newRightSE) {\n    this.rightSE = newRightSE\n    this.rightSE.segment = this\n    this.rightSE.otherSE = this.leftSE\n    this.leftSE.otherSE = this.rightSE\n  }\n\n  bbox() {\n    const y1 = this.leftSE.point.y\n    const y2 = this.rightSE.point.y\n    return {\n      ll: { x: this.leftSE.point.x, y: y1 < y2 ? y1 : y2 },\n      ur: { x: this.rightSE.point.x, y: y1 > y2 ? y1 : y2 },\n    }\n  }\n\n  /* A vector from the left point to the right */\n  vector() {\n    return {\n      x: this.rightSE.point.x - this.leftSE.point.x,\n      y: this.rightSE.point.y - this.leftSE.point.y,\n    }\n  }\n\n  isAnEndpoint(pt) {\n    return (\n      (pt.x === this.leftSE.point.x && pt.y === this.leftSE.point.y) ||\n      (pt.x === this.rightSE.point.x && pt.y === this.rightSE.point.y)\n    )\n  }\n\n  /* Compare this segment with a point.\n   *\n   * A point P is considered to be colinear to a segment if there\n   * exists a distance D such that if we travel along the segment\n   * from one * endpoint towards the other a distance D, we find\n   * ourselves at point P.\n   *\n   * Return value indicates:\n   *\n   *   1: point lies above the segment (to the left of vertical)\n   *   0: point is colinear to segment\n   *  -1: point lies below the segment (to the right of vertical)\n   */\n  comparePoint(point) {\n    if (this.isAnEndpoint(point)) return 0\n\n    const lPt = this.leftSE.point\n    const rPt = this.rightSE.point\n    const v = this.vector()\n\n    // Exactly vertical segments.\n    if (lPt.x === rPt.x) {\n      if (point.x === lPt.x) return 0\n      return point.x < lPt.x ? 1 : -1\n    }\n\n    // Nearly vertical segments with an intersection.\n    // Check to see where a point on the line with matching Y coordinate is.\n    const yDist = (point.y - lPt.y) / v.y\n    const xFromYDist = lPt.x + yDist * v.x\n    if (point.x === xFromYDist) return 0\n\n    // General case.\n    // Check to see where a point on the line with matching X coordinate is.\n    const xDist = (point.x - lPt.x) / v.x\n    const yFromXDist = lPt.y + xDist * v.y\n    if (point.y === yFromXDist) return 0\n    return point.y < yFromXDist ? -1 : 1\n  }\n\n  /**\n   * Given another segment, returns the first non-trivial intersection\n   * between the two segments (in terms of sweep line ordering), if it exists.\n   *\n   * A 'non-trivial' intersection is one that will cause one or both of the\n   * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:\n   *\n   *   * endpoint of segA with endpoint of segB --> trivial\n   *   * endpoint of segA with point along segB --> non-trivial\n   *   * endpoint of segB with point along segA --> non-trivial\n   *   * point along segA with point along segB --> non-trivial\n   *\n   * If no non-trivial intersection exists, return null\n   * Else, return null.\n   */\n  getIntersection(other) {\n    // If bboxes don't overlap, there can't be any intersections\n    const tBbox = this.bbox()\n    const oBbox = other.bbox()\n    const bboxOverlap = getBboxOverlap(tBbox, oBbox)\n    if (bboxOverlap === null) return null\n\n    // We first check to see if the endpoints can be considered intersections.\n    // This will 'snap' intersections to endpoints if possible, and will\n    // handle cases of colinearity.\n\n    const tlp = this.leftSE.point\n    const trp = this.rightSE.point\n    const olp = other.leftSE.point\n    const orp = other.rightSE.point\n\n    // does each endpoint touch the other segment?\n    // note that we restrict the 'touching' definition to only allow segments\n    // to touch endpoints that lie forward from where we are in the sweep line pass\n    const touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0\n    const touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0\n    const touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0\n    const touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0\n\n    // do left endpoints match?\n    if (touchesThisLSE && touchesOtherLSE) {\n      // these two cases are for colinear segments with matching left\n      // endpoints, and one segment being longer than the other\n      if (touchesThisRSE && !touchesOtherRSE) return trp\n      if (!touchesThisRSE && touchesOtherRSE) return orp\n      // either the two segments match exactly (two trival intersections)\n      // or just on their left endpoint (one trivial intersection\n      return null\n    }\n\n    // does this left endpoint matches (other doesn't)\n    if (touchesThisLSE) {\n      // check for segments that just intersect on opposing endpoints\n      if (touchesOtherRSE) {\n        if (tlp.x === orp.x && tlp.y === orp.y) return null\n      }\n      // t-intersection on left endpoint\n      return tlp\n    }\n\n    // does other left endpoint matches (this doesn't)\n    if (touchesOtherLSE) {\n      // check for segments that just intersect on opposing endpoints\n      if (touchesThisRSE) {\n        if (trp.x === olp.x && trp.y === olp.y) return null\n      }\n      // t-intersection on left endpoint\n      return olp\n    }\n\n    // trivial intersection on right endpoints\n    if (touchesThisRSE && touchesOtherRSE) return null\n\n    // t-intersections on just one right endpoint\n    if (touchesThisRSE) return trp\n    if (touchesOtherRSE) return orp\n\n    // None of our endpoints intersect. Look for a general intersection between\n    // infinite lines laid over the segments\n    const pt = intersection(tlp, this.vector(), olp, other.vector())\n\n    // are the segments parrallel? Note that if they were colinear with overlap,\n    // they would have an endpoint intersection and that case was already handled above\n    if (pt === null) return null\n\n    // is the intersection found between the lines not on the segments?\n    if (!isInBbox(bboxOverlap, pt)) return null\n\n    // round the the computed point if needed\n    return rounder.round(pt.x, pt.y)\n  }\n\n  /**\n   * Split the given segment into multiple segments on the given points.\n   *  * Each existing segment will retain its leftSE and a new rightSE will be\n   *    generated for it.\n   *  * A new segment will be generated which will adopt the original segment's\n   *    rightSE, and a new leftSE will be generated for it.\n   *  * If there are more than two points given to split on, new segments\n   *    in the middle will be generated with new leftSE and rightSE's.\n   *  * An array of the newly generated SweepEvents will be returned.\n   *\n   * Warning: input array of points is modified\n   */\n  split(point) {\n    const newEvents = []\n    const alreadyLinked = point.events !== undefined\n\n    const newLeftSE = new SweepEvent(point, true)\n    const newRightSE = new SweepEvent(point, false)\n    const oldRightSE = this.rightSE\n    this.replaceRightSE(newRightSE)\n    newEvents.push(newRightSE)\n    newEvents.push(newLeftSE)\n    const newSeg = new Segment(\n      newLeftSE,\n      oldRightSE,\n      this.rings.slice(),\n      this.windings.slice(),\n    )\n\n    // when splitting a nearly vertical downward-facing segment,\n    // sometimes one of the resulting new segments is vertical, in which\n    // case its left and right events may need to be swapped\n    if (\n      SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0\n    ) {\n      newSeg.swapEvents()\n    }\n    if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {\n      this.swapEvents()\n    }\n\n    // in the point we just used to create new sweep events with was already\n    // linked to other events, we need to check if either of the affected\n    // segments should be consumed\n    if (alreadyLinked) {\n      newLeftSE.checkForConsuming()\n      newRightSE.checkForConsuming()\n    }\n\n    return newEvents\n  }\n\n  /* Swap which event is left and right */\n  swapEvents() {\n    const tmpEvt = this.rightSE\n    this.rightSE = this.leftSE\n    this.leftSE = tmpEvt\n    this.leftSE.isLeft = true\n    this.rightSE.isLeft = false\n    for (let i = 0, iMax = this.windings.length; i < iMax; i++) {\n      this.windings[i] *= -1\n    }\n  }\n\n  /* Consume another segment. We take their rings under our wing\n   * and mark them as consumed. Use for perfectly overlapping segments */\n  consume(other) {\n    let consumer = this\n    let consumee = other\n    while (consumer.consumedBy) consumer = consumer.consumedBy\n    while (consumee.consumedBy) consumee = consumee.consumedBy\n\n    const cmp = Segment.compare(consumer, consumee)\n    if (cmp === 0) return // already consumed\n    // the winner of the consumption is the earlier segment\n    // according to sweep line ordering\n    if (cmp > 0) {\n      const tmp = consumer\n      consumer = consumee\n      consumee = tmp\n    }\n\n    // make sure a segment doesn't consume it's prev\n    if (consumer.prev === consumee) {\n      const tmp = consumer\n      consumer = consumee\n      consumee = tmp\n    }\n\n    for (let i = 0, iMax = consumee.rings.length; i < iMax; i++) {\n      const ring = consumee.rings[i]\n      const winding = consumee.windings[i]\n      const index = consumer.rings.indexOf(ring)\n      if (index === -1) {\n        consumer.rings.push(ring)\n        consumer.windings.push(winding)\n      } else consumer.windings[index] += winding\n    }\n    consumee.rings = null\n    consumee.windings = null\n    consumee.consumedBy = consumer\n\n    // mark sweep events consumed as to maintain ordering in sweep event queue\n    consumee.leftSE.consumedBy = consumer.leftSE\n    consumee.rightSE.consumedBy = consumer.rightSE\n  }\n\n  /* The first segment previous segment chain that is in the result */\n  prevInResult() {\n    if (this._prevInResult !== undefined) return this._prevInResult\n    if (!this.prev) this._prevInResult = null\n    else if (this.prev.isInResult()) this._prevInResult = this.prev\n    else this._prevInResult = this.prev.prevInResult()\n    return this._prevInResult\n  }\n\n  beforeState() {\n    if (this._beforeState !== undefined) return this._beforeState\n    if (!this.prev)\n      this._beforeState = {\n        rings: [],\n        windings: [],\n        multiPolys: [],\n      }\n    else {\n      const seg = this.prev.consumedBy || this.prev\n      this._beforeState = seg.afterState()\n    }\n    return this._beforeState\n  }\n\n  afterState() {\n    if (this._afterState !== undefined) return this._afterState\n\n    const beforeState = this.beforeState()\n    this._afterState = {\n      rings: beforeState.rings.slice(0),\n      windings: beforeState.windings.slice(0),\n      multiPolys: [],\n    }\n    const ringsAfter = this._afterState.rings\n    const windingsAfter = this._afterState.windings\n    const mpsAfter = this._afterState.multiPolys\n\n    // calculate ringsAfter, windingsAfter\n    for (let i = 0, iMax = this.rings.length; i < iMax; i++) {\n      const ring = this.rings[i]\n      const winding = this.windings[i]\n      const index = ringsAfter.indexOf(ring)\n      if (index === -1) {\n        ringsAfter.push(ring)\n        windingsAfter.push(winding)\n      } else windingsAfter[index] += winding\n    }\n\n    // calcualte polysAfter\n    const polysAfter = []\n    const polysExclude = []\n    for (let i = 0, iMax = ringsAfter.length; i < iMax; i++) {\n      if (windingsAfter[i] === 0) continue // non-zero rule\n      const ring = ringsAfter[i]\n      const poly = ring.poly\n      if (polysExclude.indexOf(poly) !== -1) continue\n      if (ring.isExterior) polysAfter.push(poly)\n      else {\n        if (polysExclude.indexOf(poly) === -1) polysExclude.push(poly)\n        const index = polysAfter.indexOf(ring.poly)\n        if (index !== -1) polysAfter.splice(index, 1)\n      }\n    }\n\n    // calculate multiPolysAfter\n    for (let i = 0, iMax = polysAfter.length; i < iMax; i++) {\n      const mp = polysAfter[i].multiPoly\n      if (mpsAfter.indexOf(mp) === -1) mpsAfter.push(mp)\n    }\n\n    return this._afterState\n  }\n\n  /* Is this segment part of the final result? */\n  isInResult() {\n    // if we've been consumed, we're not in the result\n    if (this.consumedBy) return false\n\n    if (this._isInResult !== undefined) return this._isInResult\n\n    const mpsBefore = this.beforeState().multiPolys\n    const mpsAfter = this.afterState().multiPolys\n\n    switch (operation.type) {\n      case \"union\": {\n        // UNION - included iff:\n        //  * On one side of us there is 0 poly interiors AND\n        //  * On the other side there is 1 or more.\n        const noBefores = mpsBefore.length === 0\n        const noAfters = mpsAfter.length === 0\n        this._isInResult = noBefores !== noAfters\n        break\n      }\n\n      case \"intersection\": {\n        // INTERSECTION - included iff:\n        //  * on one side of us all multipolys are rep. with poly interiors AND\n        //  * on the other side of us, not all multipolys are repsented\n        //    with poly interiors\n        let least\n        let most\n        if (mpsBefore.length < mpsAfter.length) {\n          least = mpsBefore.length\n          most = mpsAfter.length\n        } else {\n          least = mpsAfter.length\n          most = mpsBefore.length\n        }\n        this._isInResult = most === operation.numMultiPolys && least < most\n        break\n      }\n\n      case \"xor\": {\n        // XOR - included iff:\n        //  * the difference between the number of multipolys represented\n        //    with poly interiors on our two sides is an odd number\n        const diff = Math.abs(mpsBefore.length - mpsAfter.length)\n        this._isInResult = diff % 2 === 1\n        break\n      }\n\n      case \"difference\": {\n        // DIFFERENCE included iff:\n        //  * on exactly one side, we have just the subject\n        const isJustSubject = (mps) => mps.length === 1 && mps[0].isSubject\n        this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter)\n        break\n      }\n\n      default:\n        throw new Error(`Unrecognized operation type found ${operation.type}`)\n    }\n\n    return this._isInResult\n  }\n}\n","import rounder from \"./rounder\"\nimport Segment from \"./segment\"\n\nexport class RingIn {\n  constructor(geomRing, poly, isExterior) {\n    if (!Array.isArray(geomRing) || geomRing.length === 0) {\n      throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\")\n    }\n\n    this.poly = poly\n    this.isExterior = isExterior\n    this.segments = []\n\n    if (\n      typeof geomRing[0][0] !== \"number\" ||\n      typeof geomRing[0][1] !== \"number\"\n    ) {\n      throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\")\n    }\n\n    const firstPoint = rounder.round(geomRing[0][0], geomRing[0][1])\n    this.bbox = {\n      ll: { x: firstPoint.x, y: firstPoint.y },\n      ur: { x: firstPoint.x, y: firstPoint.y },\n    }\n\n    let prevPoint = firstPoint\n    for (let i = 1, iMax = geomRing.length; i < iMax; i++) {\n      if (\n        typeof geomRing[i][0] !== \"number\" ||\n        typeof geomRing[i][1] !== \"number\"\n      ) {\n        throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\")\n      }\n      let point = rounder.round(geomRing[i][0], geomRing[i][1])\n      // skip repeated points\n      if (point.x === prevPoint.x && point.y === prevPoint.y) continue\n      this.segments.push(Segment.fromRing(prevPoint, point, this))\n      if (point.x < this.bbox.ll.x) this.bbox.ll.x = point.x\n      if (point.y < this.bbox.ll.y) this.bbox.ll.y = point.y\n      if (point.x > this.bbox.ur.x) this.bbox.ur.x = point.x\n      if (point.y > this.bbox.ur.y) this.bbox.ur.y = point.y\n      prevPoint = point\n    }\n    // add segment from last to first if last is not the same as first\n    if (firstPoint.x !== prevPoint.x || firstPoint.y !== prevPoint.y) {\n      this.segments.push(Segment.fromRing(prevPoint, firstPoint, this))\n    }\n  }\n\n  getSweepEvents() {\n    const sweepEvents = []\n    for (let i = 0, iMax = this.segments.length; i < iMax; i++) {\n      const segment = this.segments[i]\n      sweepEvents.push(segment.leftSE)\n      sweepEvents.push(segment.rightSE)\n    }\n    return sweepEvents\n  }\n}\n\nexport class PolyIn {\n  constructor(geomPoly, multiPoly) {\n    if (!Array.isArray(geomPoly)) {\n      throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\")\n    }\n    this.exteriorRing = new RingIn(geomPoly[0], this, true)\n    // copy by value\n    this.bbox = {\n      ll: { x: this.exteriorRing.bbox.ll.x, y: this.exteriorRing.bbox.ll.y },\n      ur: { x: this.exteriorRing.bbox.ur.x, y: this.exteriorRing.bbox.ur.y },\n    }\n    this.interiorRings = []\n    for (let i = 1, iMax = geomPoly.length; i < iMax; i++) {\n      const ring = new RingIn(geomPoly[i], this, false)\n      if (ring.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = ring.bbox.ll.x\n      if (ring.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = ring.bbox.ll.y\n      if (ring.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = ring.bbox.ur.x\n      if (ring.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = ring.bbox.ur.y\n      this.interiorRings.push(ring)\n    }\n    this.multiPoly = multiPoly\n  }\n\n  getSweepEvents() {\n    const sweepEvents = this.exteriorRing.getSweepEvents()\n    for (let i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n      const ringSweepEvents = this.interiorRings[i].getSweepEvents()\n      for (let j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {\n        sweepEvents.push(ringSweepEvents[j])\n      }\n    }\n    return sweepEvents\n  }\n}\n\nexport class MultiPolyIn {\n  constructor(geom, isSubject) {\n    if (!Array.isArray(geom)) {\n      throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\")\n    }\n\n    try {\n      // if the input looks like a polygon, convert it to a multipolygon\n      if (typeof geom[0][0][0] === \"number\") geom = [geom]\n    } catch (ex) {\n      // The input is either malformed or has empty arrays.\n      // In either case, it will be handled later on.\n    }\n\n    this.polys = []\n    this.bbox = {\n      ll: { x: Number.POSITIVE_INFINITY, y: Number.POSITIVE_INFINITY },\n      ur: { x: Number.NEGATIVE_INFINITY, y: Number.NEGATIVE_INFINITY },\n    }\n    for (let i = 0, iMax = geom.length; i < iMax; i++) {\n      const poly = new PolyIn(geom[i], this)\n      if (poly.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = poly.bbox.ll.x\n      if (poly.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = poly.bbox.ll.y\n      if (poly.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = poly.bbox.ur.x\n      if (poly.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = poly.bbox.ur.y\n      this.polys.push(poly)\n    }\n    this.isSubject = isSubject\n  }\n\n  getSweepEvents() {\n    const sweepEvents = []\n    for (let i = 0, iMax = this.polys.length; i < iMax; i++) {\n      const polySweepEvents = this.polys[i].getSweepEvents()\n      for (let j = 0, jMax = polySweepEvents.length; j < jMax; j++) {\n        sweepEvents.push(polySweepEvents[j])\n      }\n    }\n    return sweepEvents\n  }\n}\n","import { compareVectorAngles } from \"./vector\"\nimport SweepEvent from \"./sweep-event\"\n\nexport class RingOut {\n  /* Given the segments from the sweep line pass, compute & return a series\n   * of closed rings from all the segments marked to be part of the result */\n  static factory(allSegments) {\n    const ringsOut = []\n\n    for (let i = 0, iMax = allSegments.length; i < iMax; i++) {\n      const segment = allSegments[i]\n      if (!segment.isInResult() || segment.ringOut) continue\n\n      let prevEvent = null\n      let event = segment.leftSE\n      let nextEvent = segment.rightSE\n      const events = [event]\n\n      const startingPoint = event.point\n      const intersectionLEs = []\n\n      /* Walk the chain of linked events to form a closed ring */\n      while (true) {\n        prevEvent = event\n        event = nextEvent\n        events.push(event)\n\n        /* Is the ring complete? */\n        if (event.point === startingPoint) break\n\n        while (true) {\n          const availableLEs = event.getAvailableLinkedEvents()\n\n          /* Did we hit a dead end? This shouldn't happen. Indicates some earlier\n           * part of the algorithm malfunctioned... please file a bug report. */\n          if (availableLEs.length === 0) {\n            const firstPt = events[0].point\n            const lastPt = events[events.length - 1].point\n            throw new Error(\n              `Unable to complete output ring starting at [${firstPt.x},` +\n                ` ${firstPt.y}]. Last matching segment found ends at` +\n                ` [${lastPt.x}, ${lastPt.y}].`,\n            )\n          }\n\n          /* Only one way to go, so cotinue on the path */\n          if (availableLEs.length === 1) {\n            nextEvent = availableLEs[0].otherSE\n            break\n          }\n\n          /* We must have an intersection. Check for a completed loop */\n          let indexLE = null\n          for (let j = 0, jMax = intersectionLEs.length; j < jMax; j++) {\n            if (intersectionLEs[j].point === event.point) {\n              indexLE = j\n              break\n            }\n          }\n          /* Found a completed loop. Cut that off and make a ring */\n          if (indexLE !== null) {\n            const intersectionLE = intersectionLEs.splice(indexLE)[0]\n            const ringEvents = events.splice(intersectionLE.index)\n            ringEvents.unshift(ringEvents[0].otherSE)\n            ringsOut.push(new RingOut(ringEvents.reverse()))\n            continue\n          }\n          /* register the intersection */\n          intersectionLEs.push({\n            index: events.length,\n            point: event.point,\n          })\n          /* Choose the left-most option to continue the walk */\n          const comparator = event.getLeftmostComparator(prevEvent)\n          nextEvent = availableLEs.sort(comparator)[0].otherSE\n          break\n        }\n      }\n\n      ringsOut.push(new RingOut(events))\n    }\n    return ringsOut\n  }\n\n  constructor(events) {\n    this.events = events\n    for (let i = 0, iMax = events.length; i < iMax; i++) {\n      events[i].segment.ringOut = this\n    }\n    this.poly = null\n  }\n\n  getGeom() {\n    // Remove superfluous points (ie extra points along a straight line),\n    let prevPt = this.events[0].point\n    const points = [prevPt]\n    for (let i = 1, iMax = this.events.length - 1; i < iMax; i++) {\n      const pt = this.events[i].point\n      const nextPt = this.events[i + 1].point\n      if (compareVectorAngles(pt, prevPt, nextPt) === 0) continue\n      points.push(pt)\n      prevPt = pt\n    }\n\n    // ring was all (within rounding error of angle calc) colinear points\n    if (points.length === 1) return null\n\n    // check if the starting point is necessary\n    const pt = points[0]\n    const nextPt = points[1]\n    if (compareVectorAngles(pt, prevPt, nextPt) === 0) points.shift()\n\n    points.push(points[0])\n    const step = this.isExteriorRing() ? 1 : -1\n    const iStart = this.isExteriorRing() ? 0 : points.length - 1\n    const iEnd = this.isExteriorRing() ? points.length : -1\n    const orderedPoints = []\n    for (let i = iStart; i != iEnd; i += step)\n      orderedPoints.push([points[i].x, points[i].y])\n    return orderedPoints\n  }\n\n  isExteriorRing() {\n    if (this._isExteriorRing === undefined) {\n      const enclosing = this.enclosingRing()\n      this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true\n    }\n    return this._isExteriorRing\n  }\n\n  enclosingRing() {\n    if (this._enclosingRing === undefined) {\n      this._enclosingRing = this._calcEnclosingRing()\n    }\n    return this._enclosingRing\n  }\n\n  /* Returns the ring that encloses this one, if any */\n  _calcEnclosingRing() {\n    // start with the ealier sweep line event so that the prevSeg\n    // chain doesn't lead us inside of a loop of ours\n    let leftMostEvt = this.events[0]\n    for (let i = 1, iMax = this.events.length; i < iMax; i++) {\n      const evt = this.events[i]\n      if (SweepEvent.compare(leftMostEvt, evt) > 0) leftMostEvt = evt\n    }\n\n    let prevSeg = leftMostEvt.segment.prevInResult()\n    let prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null\n\n    while (true) {\n      // no segment found, thus no ring can enclose us\n      if (!prevSeg) return null\n\n      // no segments below prev segment found, thus the ring of the prev\n      // segment must loop back around and enclose us\n      if (!prevPrevSeg) return prevSeg.ringOut\n\n      // if the two segments are of different rings, the ring of the prev\n      // segment must either loop around us or the ring of the prev prev\n      // seg, which would make us and the ring of the prev peers\n      if (prevPrevSeg.ringOut !== prevSeg.ringOut) {\n        if (prevPrevSeg.ringOut.enclosingRing() !== prevSeg.ringOut) {\n          return prevSeg.ringOut\n        } else return prevSeg.ringOut.enclosingRing()\n      }\n\n      // two segments are from the same ring, so this was a penisula\n      // of that ring. iterate downward, keep searching\n      prevSeg = prevPrevSeg.prevInResult()\n      prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null\n    }\n  }\n}\n\nexport class PolyOut {\n  constructor(exteriorRing) {\n    this.exteriorRing = exteriorRing\n    exteriorRing.poly = this\n    this.interiorRings = []\n  }\n\n  addInterior(ring) {\n    this.interiorRings.push(ring)\n    ring.poly = this\n  }\n\n  getGeom() {\n    const geom = [this.exteriorRing.getGeom()]\n    // exterior ring was all (within rounding error of angle calc) colinear points\n    if (geom[0] === null) return null\n    for (let i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n      const ringGeom = this.interiorRings[i].getGeom()\n      // interior ring was all (within rounding error of angle calc) colinear points\n      if (ringGeom === null) continue\n      geom.push(ringGeom)\n    }\n    return geom\n  }\n}\n\nexport class MultiPolyOut {\n  constructor(rings) {\n    this.rings = rings\n    this.polys = this._composePolys(rings)\n  }\n\n  getGeom() {\n    const geom = []\n    for (let i = 0, iMax = this.polys.length; i < iMax; i++) {\n      const polyGeom = this.polys[i].getGeom()\n      // exterior ring was all (within rounding error of angle calc) colinear points\n      if (polyGeom === null) continue\n      geom.push(polyGeom)\n    }\n    return geom\n  }\n\n  _composePolys(rings) {\n    const polys = []\n    for (let i = 0, iMax = rings.length; i < iMax; i++) {\n      const ring = rings[i]\n      if (ring.poly) continue\n      if (ring.isExteriorRing()) polys.push(new PolyOut(ring))\n      else {\n        const enclosingRing = ring.enclosingRing()\n        if (!enclosingRing.poly) polys.push(new PolyOut(enclosingRing))\n        enclosingRing.poly.addInterior(ring)\n      }\n    }\n    return polys\n  }\n}\n","import SplayTree from \"splaytree\"\nimport Segment from \"./segment\"\nimport SweepEvent from \"./sweep-event\"\n\n/**\n * NOTE:  We must be careful not to change any segments while\n *        they are in the SplayTree. AFAIK, there's no way to tell\n *        the tree to rebalance itself - thus before splitting\n *        a segment that's in the tree, we remove it from the tree,\n *        do the split, then re-insert it. (Even though splitting a\n *        segment *shouldn't* change its correct position in the\n *        sweep line tree, the reality is because of rounding errors,\n *        it sometimes does.)\n */\n\nexport default class SweepLine {\n  constructor(queue, comparator = Segment.compare) {\n    this.queue = queue\n    this.tree = new SplayTree(comparator)\n    this.segments = []\n  }\n\n  process(event) {\n    const segment = event.segment\n    const newEvents = []\n\n    // if we've already been consumed by another segment,\n    // clean up our body parts and get out\n    if (event.consumedBy) {\n      if (event.isLeft) this.queue.remove(event.otherSE)\n      else this.tree.remove(segment)\n      return newEvents\n    }\n\n    const node = event.isLeft\n      ? this.tree.insert(segment)\n      : this.tree.find(segment)\n\n    if (!node)\n      throw new Error(\n        `Unable to find segment #${segment.id} ` +\n          `[${segment.leftSE.point.x}, ${segment.leftSE.point.y}] -> ` +\n          `[${segment.rightSE.point.x}, ${segment.rightSE.point.y}] ` +\n          \"in SweepLine tree. Please submit a bug report.\",\n      )\n\n    let prevNode = node\n    let nextNode = node\n    let prevSeg = undefined\n    let nextSeg = undefined\n\n    // skip consumed segments still in tree\n    while (prevSeg === undefined) {\n      prevNode = this.tree.prev(prevNode)\n      if (prevNode === null) prevSeg = null\n      else if (prevNode.key.consumedBy === undefined) prevSeg = prevNode.key\n    }\n\n    // skip consumed segments still in tree\n    while (nextSeg === undefined) {\n      nextNode = this.tree.next(nextNode)\n      if (nextNode === null) nextSeg = null\n      else if (nextNode.key.consumedBy === undefined) nextSeg = nextNode.key\n    }\n\n    if (event.isLeft) {\n      // Check for intersections against the previous segment in the sweep line\n      let prevMySplitter = null\n      if (prevSeg) {\n        const prevInter = prevSeg.getIntersection(segment)\n        if (prevInter !== null) {\n          if (!segment.isAnEndpoint(prevInter)) prevMySplitter = prevInter\n          if (!prevSeg.isAnEndpoint(prevInter)) {\n            const newEventsFromSplit = this._splitSafely(prevSeg, prevInter)\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i])\n            }\n          }\n        }\n      }\n\n      // Check for intersections against the next segment in the sweep line\n      let nextMySplitter = null\n      if (nextSeg) {\n        const nextInter = nextSeg.getIntersection(segment)\n        if (nextInter !== null) {\n          if (!segment.isAnEndpoint(nextInter)) nextMySplitter = nextInter\n          if (!nextSeg.isAnEndpoint(nextInter)) {\n            const newEventsFromSplit = this._splitSafely(nextSeg, nextInter)\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i])\n            }\n          }\n        }\n      }\n\n      // For simplicity, even if we find more than one intersection we only\n      // spilt on the 'earliest' (sweep-line style) of the intersections.\n      // The other intersection will be handled in a future process().\n      if (prevMySplitter !== null || nextMySplitter !== null) {\n        let mySplitter = null\n        if (prevMySplitter === null) mySplitter = nextMySplitter\n        else if (nextMySplitter === null) mySplitter = prevMySplitter\n        else {\n          const cmpSplitters = SweepEvent.comparePoints(\n            prevMySplitter,\n            nextMySplitter,\n          )\n          mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter\n        }\n\n        // Rounding errors can cause changes in ordering,\n        // so remove afected segments and right sweep events before splitting\n        this.queue.remove(segment.rightSE)\n        newEvents.push(segment.rightSE)\n\n        const newEventsFromSplit = segment.split(mySplitter)\n        for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n          newEvents.push(newEventsFromSplit[i])\n        }\n      }\n\n      if (newEvents.length > 0) {\n        // We found some intersections, so re-do the current event to\n        // make sure sweep line ordering is totally consistent for later\n        // use with the segment 'prev' pointers\n        this.tree.remove(segment)\n        newEvents.push(event)\n      } else {\n        // done with left event\n        this.segments.push(segment)\n        segment.prev = prevSeg\n      }\n    } else {\n      // event.isRight\n\n      // since we're about to be removed from the sweep line, check for\n      // intersections between our previous and next segments\n      if (prevSeg && nextSeg) {\n        const inter = prevSeg.getIntersection(nextSeg)\n        if (inter !== null) {\n          if (!prevSeg.isAnEndpoint(inter)) {\n            const newEventsFromSplit = this._splitSafely(prevSeg, inter)\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i])\n            }\n          }\n          if (!nextSeg.isAnEndpoint(inter)) {\n            const newEventsFromSplit = this._splitSafely(nextSeg, inter)\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i])\n            }\n          }\n        }\n      }\n\n      this.tree.remove(segment)\n    }\n\n    return newEvents\n  }\n\n  /* Safely split a segment that is currently in the datastructures\n   * IE - a segment other than the one that is currently being processed. */\n  _splitSafely(seg, pt) {\n    // Rounding errors can cause changes in ordering,\n    // so remove afected segments and right sweep events before splitting\n    // removeNode() doesn't work, so have re-find the seg\n    // https://github.com/w8r/splay-tree/pull/5\n    this.tree.remove(seg)\n    const rightSE = seg.rightSE\n    this.queue.remove(rightSE)\n    const newEvents = seg.split(pt)\n    newEvents.push(rightSE)\n    // splitting can trigger consumption\n    if (seg.consumedBy === undefined) this.tree.insert(seg)\n    return newEvents\n  }\n}\n","import SplayTree from \"splaytree\"\nimport { getBboxOverlap } from \"./bbox\"\nimport * as geomIn from \"./geom-in\"\nimport * as geomOut from \"./geom-out\"\nimport rounder from \"./rounder\"\nimport SweepEvent from \"./sweep-event\"\nimport SweepLine from \"./sweep-line\"\n\n// Limits on iterative processes to prevent infinite loops - usually caused by floating-point math round-off errors.\nconst POLYGON_CLIPPING_MAX_QUEUE_SIZE =\n  (typeof process !== \"undefined\" &&\n    process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE) ||\n  1000000\nconst POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS =\n  (typeof process !== \"undefined\" &&\n    process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS) ||\n  1000000\n\nexport class Operation {\n  run(type, geom, moreGeoms) {\n    operation.type = type\n    rounder.reset()\n\n    /* Convert inputs to MultiPoly objects */\n    const multipolys = [new geomIn.MultiPolyIn(geom, true)]\n    for (let i = 0, iMax = moreGeoms.length; i < iMax; i++) {\n      multipolys.push(new geomIn.MultiPolyIn(moreGeoms[i], false))\n    }\n    operation.numMultiPolys = multipolys.length\n\n    /* BBox optimization for difference operation\n     * If the bbox of a multipolygon that's part of the clipping doesn't\n     * intersect the bbox of the subject at all, we can just drop that\n     * multiploygon. */\n    if (operation.type === \"difference\") {\n      // in place removal\n      const subject = multipolys[0]\n      let i = 1\n      while (i < multipolys.length) {\n        if (getBboxOverlap(multipolys[i].bbox, subject.bbox) !== null) i++\n        else multipolys.splice(i, 1)\n      }\n    }\n\n    /* BBox optimization for intersection operation\n     * If we can find any pair of multipolygons whose bbox does not overlap,\n     * then the result will be empty. */\n    if (operation.type === \"intersection\") {\n      // TODO: this is O(n^2) in number of polygons. By sorting the bboxes,\n      //       it could be optimized to O(n * ln(n))\n      for (let i = 0, iMax = multipolys.length; i < iMax; i++) {\n        const mpA = multipolys[i]\n        for (let j = i + 1, jMax = multipolys.length; j < jMax; j++) {\n          if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null) return []\n        }\n      }\n    }\n\n    /* Put segment endpoints in a priority queue */\n    const queue = new SplayTree(SweepEvent.compare)\n    for (let i = 0, iMax = multipolys.length; i < iMax; i++) {\n      const sweepEvents = multipolys[i].getSweepEvents()\n      for (let j = 0, jMax = sweepEvents.length; j < jMax; j++) {\n        queue.insert(sweepEvents[j])\n\n        if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {\n          // prevents an infinite loop, an otherwise common manifestation of bugs\n          throw new Error(\n            \"Infinite loop when putting segment endpoints in a priority queue \" +\n              \"(queue size too big). Please file a bug report.\",\n          )\n        }\n      }\n    }\n\n    /* Pass the sweep line over those endpoints */\n    const sweepLine = new SweepLine(queue)\n    let prevQueueSize = queue.size\n    let node = queue.pop()\n    while (node) {\n      const evt = node.key\n      if (queue.size === prevQueueSize) {\n        // prevents an infinite loop, an otherwise common manifestation of bugs\n        const seg = evt.segment\n        throw new Error(\n          `Unable to pop() ${evt.isLeft ? \"left\" : \"right\"} SweepEvent ` +\n            `[${evt.point.x}, ${evt.point.y}] from segment #${seg.id} ` +\n            `[${seg.leftSE.point.x}, ${seg.leftSE.point.y}] -> ` +\n            `[${seg.rightSE.point.x}, ${seg.rightSE.point.y}] from queue. ` +\n            \"Please file a bug report.\",\n        )\n      }\n\n      if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {\n        // prevents an infinite loop, an otherwise common manifestation of bugs\n        throw new Error(\n          \"Infinite loop when passing sweep line over endpoints \" +\n            \"(queue size too big). Please file a bug report.\",\n        )\n      }\n\n      if (sweepLine.segments.length > POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS) {\n        // prevents an infinite loop, an otherwise common manifestation of bugs\n        throw new Error(\n          \"Infinite loop when passing sweep line over endpoints \" +\n            \"(too many sweep line segments). Please file a bug report.\",\n        )\n      }\n\n      const newEvents = sweepLine.process(evt)\n      for (let i = 0, iMax = newEvents.length; i < iMax; i++) {\n        const evt = newEvents[i]\n        if (evt.consumedBy === undefined) queue.insert(evt)\n      }\n      prevQueueSize = queue.size\n      node = queue.pop()\n    }\n\n    // free some memory we don't need anymore\n    rounder.reset()\n\n    /* Collect and compile segments we're keeping into a multipolygon */\n    const ringsOut = geomOut.RingOut.factory(sweepLine.segments)\n    const result = new geomOut.MultiPolyOut(ringsOut)\n    return result.getGeom()\n  }\n}\n\n// singleton available by import\nconst operation = new Operation()\n\nexport default operation\n","import operation from \"./operation\"\n\nconst union = (geom, ...moreGeoms) => operation.run(\"union\", geom, moreGeoms)\n\nconst intersection = (geom, ...moreGeoms) =>\n  operation.run(\"intersection\", geom, moreGeoms)\n\nconst xor = (geom, ...moreGeoms) => operation.run(\"xor\", geom, moreGeoms)\n\nconst difference = (subjectGeom, ...clippingGeoms) =>\n  operation.run(\"difference\", subjectGeom, clippingGeoms)\n\nexport default {\n  union: union,\n  intersection: intersection,\n  xor: xor,\n  difference: difference,\n}\n"],"names":["isInBbox","bbox","point","ll","x","ur","y","getBboxOverlap","b1","b2","lowerX","upperX","epsilon","Number","EPSILON","undefined","Math","pow","cmp","a","b","abs","PtRounder","_classCallCheck","this","reset","xRounder","CoordRounder","yRounder","round","tree","SplayTree","value","coord","node","add","key","rounder","crossProduct","dotProduct","compareVectorAngles","basePt","endPt1","endPt2","res","orient2d","length","v","sqrt","cosineOfAngle","pShared","pBase","pAngle","vBase","vAngle","horizontalIntersection","pt","verticalIntersection","SweepEvent","isLeft","events","push","other","Error","otherEvents","i","iMax","evt","checkForConsuming","numEvents","evt1","segment","consumedBy","j","evt2","otherSE","consume","ringOut","isInResult","baseEvent","_this","cache","Map","fillCache","linkedEvent","nextEvent","set","sine","cosine","has","_cache$get","get","asine","acosine","_cache$get2","bsine","bcosine","ptCmp","comparePoints","link","Segment","compare","aPt","bPt","segmentId","leftSE","rightSE","rings","windings","id","newRightSE","y1","y2","isAnEndpoint","lPt","rPt","vector","yDist","xFromYDist","xDist","yFromXDist","tBbox","oBbox","bboxOverlap","tlp","trp","olp","orp","touchesOtherLSE","comparePoint","touchesThisLSE","touchesOtherRSE","touchesThisRSE","pt1","v1","pt2","v2","kross","ve","d1","d2","intersection","newEvents","alreadyLinked","newLeftSE","oldRightSE","replaceRightSE","newSeg","slice","swapEvents","tmpEvt","consumer","consumee","tmp","prev","ring","winding","index","indexOf","_prevInResult","prevInResult","_beforeState","seg","afterState","multiPolys","_afterState","beforeState","ringsAfter","windingsAfter","mpsAfter","polysAfter","polysExclude","poly","isExterior","splice","mp","multiPoly","_isInResult","mpsBefore","operation","type","noBefores","noAfters","least","most","numMultiPolys","diff","isJustSubject","mps","isSubject","concat","alx","blx","arx","brx","aly","bly","ary","bry","aCmpBLeft","bCmpARight","bCmpALeft","aCmpBRight","ay","ax","by","bx","leftPt","rightPt","cmpPts","RingIn","geomRing","Array","isArray","segments","firstPoint","prevPoint","fromRing","_createClass","sweepEvents","PolyIn","geomPoly","exteriorRing","interiorRings","getSweepEvents","ringSweepEvents","jMax","MultiPolyIn","geom","ex","polys","POSITIVE_INFINITY","NEGATIVE_INFINITY","polySweepEvents","RingOut","prevPt","points","nextPt","shift","step","isExteriorRing","iStart","iEnd","orderedPoints","_isExteriorRing","enclosing","enclosingRing","_enclosingRing","_calcEnclosingRing","leftMostEvt","prevSeg","prevPrevSeg","allSegments","ringsOut","prevEvent","event","startingPoint","intersectionLEs","availableLEs","getAvailableLinkedEvents","firstPt","lastPt","indexLE","comparator","getLeftmostComparator","sort","intersectionLE","ringEvents","unshift","reverse","PolyOut","getGeom","ringGeom","MultiPolyOut","_composePolys","polyGeom","addInterior","SweepLine","queue","arguments","remove","insert","find","prevNode","nextNode","nextSeg","next","prevMySplitter","prevInter","getIntersection","newEventsFromSplit","_splitSafely","nextMySplitter","nextInter","mySplitter","split","inter","POLYGON_CLIPPING_MAX_QUEUE_SIZE","process","env","POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS","Operation","moreGeoms","multipolys","geomIn","subject","mpA","size","sweepLine","prevQueueSize","pop","geomOut","factory","result","union","_len","_key","run","_len2","_key2","xor","_len3","_key3","difference","subjectGeom","_len4","clippingGeoms","_key4"],"mappings":"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"}