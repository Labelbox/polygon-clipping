{"version":3,"file":"polygon-clipping.umd.min.js","sources":["../node_modules/splaytree/index.js","../src/flp.js","../src/vector.js","../src/rounder.js","../src/clean-input.js","../src/sweep-event.js","../src/segment.js","../src/bbox.js","../src/geom-in.js","../src/geom-out.js","../src/sweep-line.js","../src/operation.js","../src/index.js"],"sourcesContent":["/* follows \"An implementation of top-down splaying\"\n * by D. Sleator <sleator@cs.cmu.edu> March 1992\n */\n\n/**\n * @typedef {*} Key\n */\n\n\n/**\n * @typedef {*} Value\n */\n\n\n/**\n * @typedef {function(node:Node):void} Visitor\n */\n\n\n/**\n * @typedef {function(a:Key, b:Key):number} Comparator\n */\n\n\n/**\n * @param {function(node:Node):string} NodePrinter\n */\n\n\n/**\n * @typedef {Object}  Node\n * @property {Key}    Key\n * @property {Value=} data\n * @property {Node}   left\n * @property {Node}   right\n */\n\nclass Node {\n\n  constructor (key, data) {\n    this.key    = key;\n    this.data   = data;\n    this.left   = null;\n    this.right  = null;\n  }\n}\n\nfunction DEFAULT_COMPARE (a, b) { return a > b ? 1 : a < b ? -1 : 0; }\n\n\n/**\n * Simple top down splay, not requiring i to be in the tree t.\n * @param {Key} i\n * @param {Node?} t\n * @param {Comparator} comparator\n */\nfunction splay (i, t, comparator) {\n  if (t === null) return t;\n  let l, r, y;\n  const N = new Node();\n  l = r = N;\n\n  while (true) {\n    const cmp = comparator(i, t.key);\n    //if (i < t.key) {\n    if (cmp < 0) {\n      if (t.left === null) break;\n      //if (i < t.left.key) {\n      if (comparator(i, t.left.key) < 0) {\n        y = t.left;                           /* rotate right */\n        t.left = y.right;\n        y.right = t;\n        t = y;\n        if (t.left === null) break;\n      }\n      r.left = t;                               /* link right */\n      r = t;\n      t = t.left;\n    //} else if (i > t.key) {\n    } else if (cmp > 0) {\n      if (t.right === null) break;\n      //if (i > t.right.key) {\n      if (comparator(i, t.right.key) > 0) {\n        y = t.right;                          /* rotate left */\n        t.right = y.left;\n        y.left = t;\n        t = y;\n        if (t.right === null) break;\n      }\n      l.right = t;                              /* link left */\n      l = t;\n      t = t.right;\n    } else {\n      break;\n    }\n  }\n  /* assemble */\n  l.right = t.left;\n  r.left = t.right;\n  t.left = N.right;\n  t.right = N.left;\n  return t;\n}\n\n\n/**\n * @param  {Key}        i\n * @param  {Value}      data\n * @param  {Comparator} comparator\n * @param  {Tree}       tree\n * @return {Node}      root\n */\nfunction insert (i, data, t, comparator, tree) {\n  const node = new Node(i, data);\n\n  tree._size++;\n\n  if (t === null) {\n    node.left = node.right = null;\n    return node;\n  }\n\n  t = splay(i, t, comparator);\n  const cmp = comparator(i, t.key);\n  if (cmp < 0) {\n    node.left = t.left;\n    node.right = t;\n    t.left = null;\n  } else if (cmp >= 0) {\n    node.right = t.right;\n    node.left = t;\n    t.right = null;\n  }\n  return node;\n}\n\n\n/**\n * Insert i into the tree t, unless it's already there.\n * @param  {Key}        i\n * @param  {Value}      data\n * @param  {Comparator} comparator\n * @param  {Tree}       tree\n * @return {Node}       root\n */\nfunction add (i, data, t, comparator, tree) {\n  const node = new Node(i, data);\n\n  if (t === null) {\n    node.left = node.right = null;\n    tree._size++;\n    return node;\n  }\n\n  t = splay(i, t, comparator);\n  const cmp = comparator(i, t.key);\n  if (cmp === 0) return t;\n  else {\n    if (cmp < 0) {\n      node.left = t.left;\n      node.right = t;\n      t.left = null;\n    } else if (cmp > 0) {\n      node.right = t.right;\n      node.left = t;\n      t.right = null;\n    }\n    tree._size++;\n    return node;\n  }\n}\n\n\n/**\n * Deletes i from the tree if it's there\n * @param {Key}        i\n * @param {Tree}       tree\n * @param {Comparator} comparator\n * @param {Tree}       tree\n * @return {Node}      new root\n */\nfunction remove (i, t, comparator, tree) {\n  let x;\n  if (t === null) return null;\n  t = splay(i, t, comparator);\n  var cmp = comparator(i, t.key);\n  if (cmp === 0) {               /* found it */\n    if (t.left === null) {\n      x = t.right;\n    } else {\n      x = splay(i, t.left, comparator);\n      x.right = t.right;\n    }\n    tree._size--;\n    return x;\n  }\n  return t;                         /* It wasn't there */\n}\n\n\nfunction split (key, v, comparator) {\n  let left, right;\n  if (v === null) {\n    left = right = null;\n  } else {\n    v = splay(key, v, comparator);\n\n    const cmp = comparator(v.key, key);\n    if (cmp === 0) {\n      left  = v.left;\n      right = v.right;\n    } else if (cmp < 0) {\n      right   = v.right;\n      v.right = null;\n      left    = v;\n    } else {\n      left   = v.left;\n      v.left = null;\n      right  = v;\n    }\n  }\n  return { left, right };\n}\n\n\nfunction merge (left, right, comparator) {\n  if (right === null) return left;\n  if (left  === null) return right;\n\n  right = splay(left.key, right, comparator);\n  right.left = left;\n  return right;\n}\n\n\n/**\n * Prints level of the tree\n * @param  {Node}                        root\n * @param  {String}                      prefix\n * @param  {Boolean}                     isTail\n * @param  {Array<string>}               out\n * @param  {Function(node:Node):String}  printNode\n */\nfunction printRow (root, prefix, isTail, out, printNode) {\n  if (root) {\n    out(`${ prefix }${ isTail ? '└── ' : '├── ' }${ printNode(root) }\\n`);\n    const indent = prefix + (isTail ? '    ' : '│   ');\n    if (root.left)  printRow(root.left,  indent, false, out, printNode);\n    if (root.right) printRow(root.right, indent, true,  out, printNode);\n  }\n}\n\n\nexport default class Tree {\n\n  constructor (comparator = DEFAULT_COMPARE) {\n    this._comparator = comparator;\n    this._root = null;\n    this._size = 0;\n  }\n\n\n  /**\n   * Inserts a key, allows duplicates\n   * @param  {Key}    key\n   * @param  {Value=} data\n   * @return {Node|null}\n   */\n  insert (key, data) {\n    return this._root = insert(key, data, this._root, this._comparator, this);\n  }\n\n\n  /**\n   * Adds a key, if it is not present in the tree\n   * @param  {Key}    key\n   * @param  {Value=} data\n   * @return {Node|null}\n   */\n  add (key, data) {\n    return this._root = add(key, data, this._root, this._comparator, this);\n  }\n\n\n  /**\n   * @param  {Key} key\n   * @return {Node|null}\n   */\n  remove (key) {\n    this._root = remove(key, this._root, this._comparator, this);\n  }\n\n\n  /**\n   * Removes and returns the node with smallest key\n   * @return {?Node}\n   */\n  pop () {\n    let node = this._root;\n    if (node) {\n      while (node.left) node = node.left;\n      this._root = splay(node.key,  this._root, this._comparator);\n      this._root = remove(node.key, this._root, this._comparator, this);\n      return { key: node.key, data: node.data };\n    }\n    return null;\n  }\n\n\n  /**\n   * @param  {Key} key\n   * @return {Node|null}\n   */\n  findStatic (key) {\n    let current   = this._root;\n    const compare = this._comparator;\n    while (current) {\n      const cmp = compare(key, current.key);\n      if (cmp === 0)    return current;\n      else if (cmp < 0) current = current.left;\n      else              current = current.right;\n    }\n    return null;\n  }\n\n\n  /**\n   * @param  {Key} key\n   * @return {Node|null}\n   */\n  find (key) {\n    if (this._root) {\n      this._root = splay(key, this._root, this._comparator);\n      if (this._comparator(key, this._root.key) !== 0) return null;\n    }\n    return this._root;\n  }\n\n\n  /**\n   * @param  {Key} key\n   * @return {Boolean}\n   */\n  contains (key) {\n    let current   = this._root;\n    const compare = this._comparator;\n    while (current) {\n      const cmp = compare(key, current.key);\n      if (cmp === 0)    return true;\n      else if (cmp < 0) current = current.left;\n      else              current = current.right;\n    }\n    return false;\n  }\n\n\n  /**\n   * @param  {Visitor} visitor\n   * @param  {*=}      ctx\n   * @return {SplayTree}\n   */\n  forEach (visitor, ctx) {\n    let current = this._root;\n    const Q = [];  /* Initialize stack s */\n    let done = false;\n\n    while (!done) {\n      if (current !==  null) {\n        Q.push(current);\n        current = current.left;\n      } else {\n        if (Q.length !== 0) {\n          current = Q.pop();\n          visitor.call(ctx, current);\n\n          current = current.right;\n        } else done = true;\n      }\n    }\n    return this;\n  }\n\n\n  /**\n   * Walk key range from `low` to `high`. Stops if `fn` returns a value.\n   * @param  {Key}      low\n   * @param  {Key}      high\n   * @param  {Function} fn\n   * @param  {*?}       ctx\n   * @return {SplayTree}\n   */\n  range (low, high, fn, ctx) {\n    const Q = [];\n    const compare = this._comparator;\n    let node = this._root, cmp;\n\n    while (Q.length !== 0 || node) {\n      if (node) {\n        Q.push(node);\n        node = node.left;\n      } else {\n        node = Q.pop();\n        cmp = compare(node.key, high);\n        if (cmp > 0) {\n          break;\n        } else if (compare(node.key, low) >= 0) {\n          if (fn.call(ctx, node)) return this; // stop if smth is returned\n        }\n        node = node.right;\n      }\n    }\n    return this;\n  }\n\n\n  /**\n   * Returns array of keys\n   * @return {Array<Key>}\n   */\n  keys () {\n    const keys = [];\n    this.forEach(({ key }) => keys.push(key));\n    return keys;\n  }\n\n\n  /**\n   * Returns array of all the data in the nodes\n   * @return {Array<Value>}\n   */\n  values () {\n    const values = [];\n    this.forEach(({ data }) => values.push(data));\n    return values;\n  }\n\n\n  /**\n   * @return {Key|null}\n   */\n  min() {\n    if (this._root) return this.minNode(this._root).key;\n    return null;\n  }\n\n\n  /**\n   * @return {Key|null}\n   */\n  max() {\n    if (this._root) return this.maxNode(this._root).key;\n    return null;\n  }\n\n\n  /**\n   * @return {Node|null}\n   */\n  minNode(t = this._root) {\n    if (t) while (t.left) t = t.left;\n    return t;\n  }\n\n\n  /**\n   * @return {Node|null}\n   */\n  maxNode(t = this._root) {\n    if (t) while (t.right) t = t.right;\n    return t;\n  }\n\n\n  /**\n   * Returns node at given index\n   * @param  {number} index\n   * @return {?Node}\n   */\n  at (index) {\n    let current = this._root, done = false, i = 0;\n    const Q = [];\n\n    while (!done) {\n      if (current) {\n        Q.push(current);\n        current = current.left;\n      } else {\n        if (Q.length > 0) {\n          current = Q.pop();\n          if (i === index) return current;\n          i++;\n          current = current.right;\n        } else done = true;\n      }\n    }\n    return null;\n  }\n\n\n  /**\n   * @param  {Node}   d\n   * @return {Node|null}\n   */\n  next (d) {\n    let root = this._root;\n    let successor = null;\n\n    if (d.right) {\n      successor = d.right;\n      while (successor.left) successor = successor.left;\n      return successor;\n    }\n\n    const comparator = this._comparator;\n    while (root) {\n      const cmp = comparator(d.key, root.key);\n      if (cmp === 0) break;\n      else if (cmp < 0) {\n        successor = root;\n        root = root.left;\n      } else root = root.right;\n    }\n\n    return successor;\n  }\n\n\n  /**\n   * @param  {Node} d\n   * @return {Node|null}\n   */\n  prev (d) {\n    let root = this._root;\n    let predecessor = null;\n\n    if (d.left !== null) {\n      predecessor = d.left;\n      while (predecessor.right) predecessor = predecessor.right;\n      return predecessor;\n    }\n\n    const comparator = this._comparator;\n    while (root) {\n      const cmp = comparator(d.key, root.key);\n      if (cmp === 0) break;\n      else if (cmp < 0) root = root.left;\n      else {\n        predecessor = root;\n        root = root.right;\n      }\n    }\n    return predecessor;\n  }\n\n\n  /**\n   * @return {SplayTree}\n   */\n  clear() {\n    this._root = null;\n    this._size = 0;\n    return this;\n  }\n\n\n  /**\n   * @return {NodeList}\n   */\n  toList() {\n    return toList(this._root);\n  }\n\n\n  /**\n   * Bulk-load items. Both array have to be same size\n   * @param  {Array<Key>}    keys\n   * @param  {Array<Value>}  [values]\n   * @param  {Boolean}       [presort=false] Pre-sort keys and values, using\n   *                                         tree's comparator. Sorting is done\n   *                                         in-place\n   * @return {AVLTree}\n   */\n  load (keys = [], values = [], presort = false) {\n    let size = keys.length;\n    const comparator = this._comparator;\n\n    // sort if needed\n    if (presort) sort(keys, values, 0, size - 1, comparator);\n\n    if (this._root === null) { // empty tree\n      this._root = loadRecursive(this._root, keys, values, 0, size);\n      this._size = size;\n    } else { // that re-builds the whole tree from two in-order traversals\n      const mergedList = mergeLists(this.toList(), createList(keys, values), comparator);\n      size = this._size + size;\n      this._root = sortedListToBST({ head: mergedList }, 0, size);\n    }\n    return this;\n  }\n\n\n  /**\n   * @return {Boolean}\n   */\n  isEmpty() { return this._root === null; }\n\n  get size () { return this._size; }\n\n\n  /**\n   * @param  {NodePrinter=} printNode\n   * @return {String}\n   */\n  toString (printNode = (n) => n.key) {\n    const out = [];\n    printRow(this._root, '', true, (v) => out.push(v), printNode);\n    return out.join('');\n  }\n\n\n  update (key, newKey, newData) {\n    const comparator = this._comparator;\n    let { left, right } = split(key, this._root, comparator);\n    this._size--;\n    if (comparator(key, newKey) < 0) {\n      right = insert(newKey, newData, right, comparator, this);\n    } else {\n      left = insert(newKey, newData, left, comparator, this);\n    }\n    this._root = merge(left, right, comparator);\n  }\n\n\n  split(key) {\n    return split(key, this._root, this._comparator);\n  }\n}\n\n\nfunction loadRecursive (parent, keys, values, start, end) {\n  const size = end - start;\n  if (size > 0) {\n    const middle = start + Math.floor(size / 2);\n    const key    = keys[middle];\n    const data   = values[middle];\n    const node   = { key, data, parent };\n    node.left    = loadRecursive(node, keys, values, start, middle);\n    node.right   = loadRecursive(node, keys, values, middle + 1, end);\n    return node;\n  }\n  return null;\n}\n\n\nfunction createList(keys, values) {\n  const head = { next: null };\n  let p = head;\n  for (let i = 0; i < keys.length; i++) {\n    p = p.next = { key: keys[i], data: values[i] };\n  }\n  p.next = null;\n  return head.next;\n}\n\n\nfunction toList (root) {\n  var current = root;\n  var Q = [], done = false;\n\n  const head = { next: null };\n  let p = head;\n\n  while (!done) {\n    if (current) {\n      Q.push(current);\n      current = current.left;\n    } else {\n      if (Q.length > 0) {\n        current = p = p.next = Q.pop();\n        current = current.right;\n      } else done = true;\n    }\n  }\n  p.next = null; // that'll work even if the tree was empty\n  return head.next;\n}\n\n\nfunction sortedListToBST(list, start, end) {\n  const size = end - start;\n  if (size > 0) {\n    const middle = start + Math.floor(size / 2);\n    const left = sortedListToBST(list, start, middle);\n\n    const root = list.head;\n    root.left = left;\n\n    list.head = list.head.next;\n\n    root.right = sortedListToBST(list, middle + 1, end);\n    return root;\n  }\n  return null;\n}\n\n\nfunction mergeLists (l1, l2, compare = (a, b) => a - b) {\n  const head = {}; // dummy\n  let p = head;\n\n  let p1 = l1;\n  let p2 = l2;\n\n  while (p1 !== null && p2 !== null) {\n    if (compare(p1.key, p2.key) < 0) {\n      p.next = p1;\n      p1 = p1.next;\n    } else {\n      p.next = p2;\n      p2 = p2.next;\n    }\n    p = p.next;\n  }\n\n  if (p1 !== null)      p.next = p1;\n  else if (p2 !== null) p.next = p2;\n\n  return head.next;\n}\n\n\nfunction sort(keys, values, left, right, compare) {\n  if (left >= right) return;\n\n  const pivot = keys[(left + right) >> 1];\n  let i = left - 1;\n  let j = right + 1;\n\n  while (true) {\n    do i++; while (compare(keys[i], pivot) < 0);\n    do j--; while (compare(keys[j], pivot) > 0);\n    if (i >= j) break;\n\n    let tmp = keys[i];\n    keys[i] = keys[j];\n    keys[j] = tmp;\n\n    tmp = values[i];\n    values[i] = values[j];\n    values[j] = tmp;\n  }\n\n  sort(keys, values,  left,     j, compare);\n  sort(keys, values, j + 1, right, compare);\n}\n","/* Javascript doesn't do integer math. Everything is\n * floating point with percision Number.EPSILON.\n *\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON\n */\n\nlet epsilon = Number.EPSILON\n\n// IE Polyfill\nif (epsilon === undefined) epsilon = Math.pow(2, -52)\n\nconst EPSILON_SQ = epsilon * epsilon\n\n/* FLP comparator */\nexport const cmp = (a, b) => {\n  // check if they're both 0\n  if (-epsilon < a && a < epsilon) {\n    if (-epsilon < b && b < epsilon) {\n      return 0\n    }\n  }\n\n  // check if they're flp equal\n  if ((a - b) * (a - b) < EPSILON_SQ * a * b) {\n    return 0\n  }\n\n  // normal comparison\n  return a < b ? -1 : 1\n}\n\n/* Greedy comparison. Two numbers are defined to touch\n * if their midpoint is indistinguishable from either. */\nexport const touch = (a, b) => {\n  const m = (a + b) / 2\n  return cmp(m, a) === 0 || cmp(m, b) === 0\n}\n\n/* Greedy comparison. Two points are defined to touch\n * if their midpoint is indistinguishable from either. */\nexport const touchPoints = (aPt, bPt) => {\n  // call directly to (skip touch()) cmp() for performance boost\n  const mx = (aPt.x + bPt.x) / 2\n  const aXMiss = cmp(mx, aPt.x) !== 0\n  if (aXMiss && cmp(mx, bPt.x) !== 0) return false\n\n  const my = (aPt.y + bPt.y) / 2\n  const aYMiss = cmp(my, aPt.y) !== 0\n  if (aYMiss && cmp(my, bPt.y) !== 0) return false\n\n  // we have touching on both x & y, we have to make sure it's\n  // not just on opposite points thou\n  if (aYMiss && aYMiss) return true\n  if (!aYMiss && !aYMiss) return true\n  return false\n}\n","import { cmp } from './flp'\n\n/* Cross Product of two vectors with first point at origin */\nexport const crossProduct = (a, b) => a.x * b.y - a.y * b.x\n\n/* Dot Product of two vectors with first point at origin */\nexport const dotProduct = (a, b) => a.x * b.x + a.y * b.y\n\n/* Comparator for two vectors with same starting point */\nexport const compareVectorAngles = (basePt, endPt1, endPt2) => {\n  const v1 = { x: endPt1.x - basePt.x, y: endPt1.y - basePt.y }\n  const v2 = { x: endPt2.x - basePt.x, y: endPt2.y - basePt.y }\n  const kross = crossProduct(v1, v2)\n  return cmp(kross, 0)\n}\n\nexport const length = v => Math.sqrt(dotProduct(v, v))\n\n/* Get the sine of the angle from pShared -> pAngle to pShaed -> pBase */\nexport const sineOfAngle = (pShared, pBase, pAngle) => {\n  const vBase = { x: pBase.x - pShared.x, y: pBase.y - pShared.y }\n  const vAngle = { x: pAngle.x - pShared.x, y: pAngle.y - pShared.y }\n  return crossProduct(vAngle, vBase) / length(vAngle) / length(vBase)\n}\n\n/* Get the cosine of the angle from pShared -> pAngle to pShaed -> pBase */\nexport const cosineOfAngle = (pShared, pBase, pAngle) => {\n  const vBase = { x: pBase.x - pShared.x, y: pBase.y - pShared.y }\n  const vAngle = { x: pAngle.x - pShared.x, y: pAngle.y - pShared.y }\n  return dotProduct(vAngle, vBase) / length(vAngle) / length(vBase)\n}\n\n/* Get the closest point on an line (defined by two points)\n * to another point. */\nexport const closestPoint = (ptA1, ptA2, ptB) => {\n  if (ptA1.x === ptA2.x) return { x: ptA1.x, y: ptB.y } // vertical vector\n  if (ptA1.y === ptA2.y) return { x: ptB.x, y: ptA1.y } // horizontal vector\n\n  // determinne which point is further away\n  const v1 = { x: ptA1.x - ptB.x, y: ptA1.y - ptB.y }\n  const v2 = { x: ptA2.x - ptB.x, y: ptA2.y - ptB.y }\n  let nearPt = ptA1\n  let farPt = ptA2\n  if (dotProduct(v1, v1) > dotProduct(v2, v2)) {\n    farPt = ptA1\n    nearPt = ptA2\n  }\n\n  // use the further point as our base in the calculation, so that the\n  // vectors are more parallel, providing more accurate dot product\n  const vA = { x: nearPt.x - farPt.x, y: nearPt.y - farPt.y }\n  const vB = { x: ptB.x - farPt.x, y: ptB.y - farPt.y }\n  const dist = dotProduct(vA, vB) / dotProduct(vA, vA)\n  return { x: farPt.x + dist * vA.x, y: farPt.y + dist * vA.y }\n}\n\n/* Get the x coordinate where the given line (defined by a point and vector)\n * crosses the horizontal line with the given y coordiante.\n * In the case of parrallel lines (including overlapping ones) returns null. */\nexport const horizontalIntersection = (pt, v, y) => {\n  if (v.y === 0) return null\n  return { x: pt.x + v.x / v.y * ( y - pt.y ), y: y }\n}\n\n/* Get the y coordinate where the given line (defined by a point and vector)\n * crosses the vertical line with the given x coordiante.\n * In the case of parrallel lines (including overlapping ones) returns null. */\nexport const verticalIntersection = (pt, v, x) => {\n  if (v.x === 0) return null\n  return { x: x, y: pt.y + v.y / v.x * ( x - pt.x ) }\n}\n\n/* Get the intersection of two lines, each defined by a base point and a vector.\n * In the case of parrallel lines (including overlapping ones) returns null. */\nexport const intersection = (pt1, v1, pt2, v2) => {\n  // take some shortcuts for vertical and horizontal lines\n  // this also ensures we don't calculate an intersection and then discover\n  // it's actually outside the bounding box of the line\n  if (v1.x === 0) return verticalIntersection(pt2, v2, pt1.x)\n  if (v2.x === 0) return verticalIntersection(pt1, v1, pt2.x)\n  if (v1.y === 0) return horizontalIntersection(pt2, v2, pt1.y)\n  if (v2.y === 0) return horizontalIntersection(pt1, v1, pt2.y)\n\n  // General case for non-overlapping segments.\n  // This algorithm is based on Schneider and Eberly.\n  // http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf - pg 244\n\n  const kross = crossProduct(v1, v2)\n  if (kross == 0) return null\n\n  const ve = { x: pt2.x - pt1.x, y: pt2.y - pt1.y }\n  const d1 = crossProduct(ve, v1) / kross\n  const d2 = crossProduct(ve, v2) / kross\n\n  // take the average of the two calculations to minimize rounding error\n  const x1 = pt1.x + d2 * v1.x, x2 = pt2.x + d1 * v2.x\n  const y1 = pt1.y + d2 * v1.y, y2 = pt2.y + d1 * v2.y\n  const x = (x1 + x2) / 2\n  const y = (y1 + y2) / 2\n  return { x: x, y: y }\n}\n\n/* Given a vector, return one that is perpendicular */\nexport const perpendicular = (v) => {\n  return { x: -v.y, y: v.x }\n}\n","import { cmp } from './flp'\nimport SplayTree from 'splaytree'\n\n/**\n * This class rounds incoming values sufficiently so that\n * floating points problems are, for the most part, avoided.\n *\n * Incoming points are have their x & y values tested against\n * all previously seen x & y values. If either is 'too close'\n * to a previously seen value, it's value is 'snapped' to the\n * previously seen value.\n *\n * All points should be rounded by this class before being\n * stored in any data structures in the rest of this algorithm.\n */\n\nclass PtRounder {\n  constructor () {\n    this.reset()\n  }\n\n  reset () {\n    this.xRounder = new CoordRounder()\n    this.yRounder = new CoordRounder()\n  }\n\n  round (x, y) {\n    return {\n      x: this.xRounder.round(x),\n      y: this.yRounder.round(y),\n    }\n  }\n}\n\nclass CoordRounder {\n  constructor () {\n    this.tree = new SplayTree()\n    // preseed with 0 so we don't end up with values < Number.EPSILON\n    this.round(0)\n  }\n\n  // Note: this can rounds input values backwards or forwards.\n  //       You might ask, why not restrict this to just rounding\n  //       forwards? Wouldn't that allow left endpoints to always\n  //       remain left endpoints during splitting (never change to\n  //       right). No - it wouldn't, because we snap intersections\n  //       to endpoints (to establish independence from the segment\n  //       angle for t-intersections).\n  round (coord) {\n    const node = this.tree.add(coord)\n\n    const prevNode = this.tree.prev(node)\n    if (prevNode !== null && cmp(node.key, prevNode.key) === 0) {\n      this.tree.remove(coord)\n      return prevNode.key\n    }\n\n    const nextNode = this.tree.next(node)\n    if (nextNode !== null && cmp(node.key, nextNode.key) === 0) {\n      this.tree.remove(coord)\n      return nextNode.key\n    }\n\n    return coord\n  }\n}\n\n// singleton available by import\nconst rounder = new PtRounder()\n\nexport default rounder\n","import { compareVectorAngles } from './vector'\nimport rounder from './rounder'\n\n/* Given input geometry as a standard array-of-arrays geojson-style\n * geometry, return one that uses objects as points, for better perf */\nexport const pointsAsObjects = geom => {\n  // we can handle well-formed multipolys and polys\n  const output = []\n  if (!Array.isArray(geom)) {\n    throw new Error('Input is not a Polygon or MultiPolygon')\n  }\n  for (let i = 0, iMax = geom.length; i < iMax; i++) {\n    if (!Array.isArray(geom[i]) || geom[i].length == 0) {\n      throw new Error('Input is not a Polygon or MultiPolygon')\n    }\n    output.push([])\n    for (let j = 0, jMax = geom[i].length; j < jMax; j++) {\n      if (!Array.isArray(geom[i][j]) || geom[i][j].length == 0) {\n        throw new Error('Input is not a Polygon or MultiPolygon')\n      }\n      if (Array.isArray(geom[i][j][0])) { // multipolygon\n        output[i].push([])\n        for (let k = 0, kMax = geom[i][j].length; k < kMax; k++) {\n          if (!Array.isArray(geom[i][j][k]) || geom[i][j][k].length < 2) {\n            throw new Error('Input is not a Polygon or MultiPolygon')\n          }\n          if (geom[i][j][k].length > 2) {\n            throw new Error(\n              'Input has more than two coordinates. ' +\n              'Only 2-dimensional polygons supported.'\n            )\n          }\n          output[i][j].push(rounder.round(geom[i][j][k][0], geom[i][j][k][1]))\n        }\n      } else { // polygon\n        if (geom[i][j].length < 2) {\n          throw new Error('Input is not a Polygon or MultiPolygon')\n        }\n        if (geom[i][j].length > 2) {\n          throw new Error(\n            'Input has more than two coordinates. ' +\n            'Only 2-dimensional polygons supported.'\n          )\n        }\n        output[i].push(rounder.round(geom[i][j][0], geom[i][j][1]))\n      }\n    }\n  }\n  return output\n}\n\n/* WARN: input modified directly */\nexport const forceMultiPoly = geom => {\n  if (Array.isArray(geom)) {\n    if (geom.length === 0) return // allow empty multipolys\n\n    if (Array.isArray(geom[0])) {\n      if (Array.isArray(geom[0][0])) {\n        if (\n          typeof geom[0][0][0].x === 'number' &&\n          typeof geom[0][0][0].y === 'number'\n        ) {\n          // multipolygon\n          return\n        }\n      }\n      if (\n        typeof geom[0][0].x === 'number' &&\n        typeof geom[0][0].y === 'number'\n      ) {\n        // polygon\n        geom.unshift(geom.splice(0))\n        return\n      }\n    }\n  }\n  throw new Error('Unrecognized input - not a polygon nor multipolygon')\n}\n\n/* WARN: input modified directly */\nexport const cleanMultiPoly = multipoly => {\n  let i = 0\n  while (i < multipoly.length) {\n    const poly = multipoly[i]\n    if (poly.length === 0) {\n      multipoly.splice(i, 1)\n      continue\n    }\n\n    const exteriorRing = poly[0]\n    cleanRing(exteriorRing)\n    // poly is dropped if exteriorRing is degenerate\n    if (exteriorRing.length === 0) {\n      multipoly.splice(i, 1)\n      continue\n    }\n\n    let j = 1\n    while (j < poly.length) {\n      const interiorRing = poly[j]\n      cleanRing(interiorRing)\n      if (interiorRing.length === 0) poly.splice(j, 1)\n      else j++\n    }\n\n    i++\n  }\n}\n\n/* Clean ring:\n *  - remove duplicate points\n *  - remove colinear points\n *  - remove rings with no area (less than 3 distinct points)\n *  - un-close rings (last point should not repeat first)\n *\n * WARN: input modified directly */\nexport const cleanRing = ring => {\n  if (ring.length === 0) return\n  const ringLengthBeforeTheClean = ring.length\n  const firstPt = ring[0]\n  const lastPt = ring[ring.length - 1]\n  if (firstPt.x === lastPt.x && firstPt.y === lastPt.y) ring.pop()\n\n  const isPointUncessary = (prevPt, pt, nextPt) =>\n    (prevPt.x === pt.x && prevPt.y === pt.y) ||\n    (nextPt.x === pt.x && nextPt.y === pt.y) ||\n    compareVectorAngles(pt, prevPt, nextPt) === 0\n\n  let i = 0\n  let prevPt, nextPt\n  while (i < ring.length) {\n    prevPt = (i === 0 ? ring[ring.length - 1] : ring[i - 1])\n    nextPt = (i === ring.length - 1 ? ring[0] : ring[i + 1])\n    if (isPointUncessary(prevPt, ring[i], nextPt)) ring.splice(i, 1)\n    else i++\n  }\n\n  // if our ring has less than 3 distinct points now (so is degenerate)\n  // shrink it down to the empty array to communicate to our caller to\n  // drop it\n  while (ring.length < 3 && ring.length > 0) ring.pop()\n\n  /**\n   * If at least one item has been removed from the ring, we need to re-run the cleanRing function with the new ring\n   * to avoid situations when new neighbor items are duplicated or have the same vector angle\n   *\n   * Imagine we have an initial ring with the following points:\n   * [{ x: 1, y: 1 },\n   *  { x: 2, y: 0 },\n   *  { x: 1, y: 0 },\n   *  { x: 1, y: 1 },\n   *  { x: 0,  y: 1 }]\n   *\n   * When we run the cleanRing with those points, it will remove from the list only the last one, as the value of the\n   * compareVectorAngles(pt, prevPt, nextPt) will be true ( compareVectorAngles({x: 0, y:1}, {x:1, y:1}, {x:1, y:1}) ),\n   * and the pre-last point will become the last one, which is the same as the first point, but the code wouldn't check\n   * that anymore and will move on with the result:\n   *\n   * [{ x: 1, y: 1 },\n   *  { x: 2, y: 0 },\n   *  { x: 1, y: 0 },\n   *  { x: 1, y: 1 }]\n   *\n   *  To prevent this kind of situation, we need to run the output data through the cleanRing function once again, if\n   *  at least one point has been removed\n   */\n  if (ringLengthBeforeTheClean !== ring.length) {\n    cleanRing(ring)\n  }\n}\n","import Segment from './segment'\nimport { cosineOfAngle, sineOfAngle } from './vector'\n\nexport default class SweepEvent {\n\n  // for ordering sweep events in the sweep event queue\n  static compare (a, b) {\n\n    // favor event with a point that the sweep line hits first\n    const ptCmp = SweepEvent.comparePoints(a.point, b.point)\n    if (ptCmp !== 0) return ptCmp\n\n    // the points are the same, so link them if needed\n    if (a.point !== b.point) a.link(b)\n\n    // favor right events over left\n    if (a.isLeft !== b.isLeft) return a.isLeft ? 1 : -1\n\n    // we have two matching left or right endpoints\n    // ordering of this case is the same as for their segments\n    return Segment.compare(a.segment, b.segment)\n  }\n\n  // for ordering points in sweep line order\n  static comparePoints (aPt, bPt) {\n    if (aPt.x < bPt.x) return -1\n    if (aPt.x > bPt.x) return 1\n\n    if (aPt.y < bPt.y) return -1\n    if (aPt.y > bPt.y) return 1\n\n    return 0\n  }\n\n  // Warning: 'point' input will be modified and re-used (for performance)\n  constructor (point, isLeft) {\n    if (point.events === undefined) point.events = [this]\n    else point.events.push(this)\n    this.point = point\n    this.isLeft = isLeft\n    // this.segment, this.otherSE set by factory\n  }\n\n  link (other) {\n    if (other.point === this.point) {\n      throw new Error('Tried to link already linked events')\n    }\n    const otherEvents = other.point.events\n    for (let i = 0, iMax = otherEvents.length; i < iMax; i++) {\n      const evt = otherEvents[i]\n      this.point.events.push(evt)\n      evt.point = this.point\n    }\n    this.checkForConsuming()\n  }\n\n  /* Do a pass over our linked events and check to see if any pair\n   * of segments match, and should be consumed. */\n  checkForConsuming () {\n    // FIXME: The loops in this method run O(n^2) => no good.\n    //        Maintain little ordered sweep event trees?\n    //        Can we maintaining an ordering that avoids the need\n    //        for the re-sorting with getLeftmostComparator in geom-out?\n\n    // Compare each pair of events to see if other events also match\n    const numEvents = this.point.events.length\n    for (let i = 0; i < numEvents; i++) {\n      const evt1 = this.point.events[i]\n      if (evt1.segment.consumedBy !== undefined) continue\n      for (let j = i + 1; j < numEvents; j++) {\n        const evt2 = this.point.events[j]\n        if (evt2.consumedBy !== undefined) continue\n        if (evt1.otherSE.point.events !== evt2.otherSE.point.events) continue\n        evt1.segment.consume(evt2.segment)\n      }\n    }\n  }\n\n  getAvailableLinkedEvents () {\n    // point.events is always of length 2 or greater\n    const events = []\n    for (let i = 0, iMax = this.point.events.length; i < iMax; i++) {\n      const evt = this.point.events[i]\n      if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {\n        events.push(evt)\n      }\n    }\n    return events\n  }\n\n  /**\n   * Returns a comparator function for sorting linked events that will\n   * favor the event that will give us the smallest left-side angle.\n   * All ring construction starts as low as possible heading to the right,\n   * so by always turning left as sharp as possible we'll get polygons\n   * without uncessary loops & holes.\n   *\n   * The comparator function has a compute cache such that it avoids\n   * re-computing already-computed values.\n   */\n  getLeftmostComparator (baseEvent) {\n    const cache = new Map()\n\n    const fillCache = linkedEvent => {\n      const nextEvent = linkedEvent.otherSE\n      cache.set(linkedEvent, {\n        sine: sineOfAngle(this.point, baseEvent.point, nextEvent.point),\n        cosine: cosineOfAngle(this.point, baseEvent.point, nextEvent.point)\n      })\n    }\n\n    return (a, b) => {\n      if (!cache.has(a)) fillCache(a)\n      if (!cache.has(b)) fillCache(b)\n\n      const { sine: asine, cosine: acosine } = cache.get(a)\n      const { sine: bsine, cosine: bcosine } = cache.get(b)\n\n      // both on or above x-axis\n      if (asine >= 0 && bsine >= 0) {\n        if (acosine < bcosine) return 1\n        if (acosine > bcosine) return -1\n        return 0\n      }\n\n      // both below x-axis\n      if (asine < 0 && bsine < 0) {\n        if (acosine < bcosine) return -1\n        if (acosine > bcosine) return 1\n        return 0\n      }\n\n      // one above x-axis, one below\n      if (bsine < asine) return -1\n      if (bsine > asine) return 1\n      return 0\n    }\n  }\n}\n","import operation from './operation'\nimport SweepEvent from './sweep-event'\nimport { isInBbox, touchesBbox, getBboxOverlap } from './bbox'\nimport { touchPoints } from './flp'\nimport { closestPoint, intersection } from './vector'\nimport rounder from './rounder'\n\n// Give segments unique ID's to get consistent sorting of\n// segments and sweep events when all else is identical\nlet segmentId = 0\n\nexport default class Segment {\n\n  /* This compare() function is for ordering segments in the sweep\n   * line tree, and does so according to the following criteria:\n   *\n   * Consider the vertical line that lies an infinestimal step to the\n   * right of the right-more of the two left endpoints of the input\n   * segments. Imagine slowly moving a point up from negative infinity\n   * in the increasing y direction. Which of the two segments will that\n   * point intersect first? That segment comes 'before' the other one.\n   *\n   * If neither segment would be intersected by such a line, (if one\n   * or more of the segments are vertical) then the line to be considered\n   * is directly on the right-more of the two left inputs.\n   */\n  static compare (a, b) {\n\n    const alx = a.leftSE.point.x\n    const blx = b.leftSE.point.x\n    const arx = a.rightSE.point.x\n    const brx = b.rightSE.point.x\n\n    // check if they're even in the same vertical plane\n    if (brx < alx) return 1\n    if (arx < blx) return -1\n\n    const aly = a.leftSE.point.y\n    const bly = b.leftSE.point.y\n    const ary = a.rightSE.point.y\n    const bry = b.rightSE.point.y\n\n    // is left endpoint of segment B the right-more?\n    if (alx < blx) {\n      // are the two segments in the same horizontal plane?\n      if (bly < aly && bly < ary) return 1\n      if (bly > aly && bly > ary) return -1\n\n      // is the B left endpoint colinear to segment A?\n      const aCmpBLeft = a.comparePoint(b.leftSE.point)\n      if (aCmpBLeft < 0) return 1\n      if (aCmpBLeft > 0) return -1\n\n      // is the A right endpoint colinear to segment B ?\n      const bCmpARight = b.comparePoint(a.rightSE.point)\n      if (bCmpARight !== 0) return bCmpARight\n\n      // colinear segments, consider the one with left-more\n      // left endpoint to be first (arbitrary?)\n      return -1\n    }\n\n    // is left endpoint of segment A the right-more?\n    if (alx > blx) {\n      if (aly < bly && aly < bry) return -1\n      if (aly > bly && aly > bry) return 1\n\n      // is the A left endpoint colinear to segment B?\n      const bCmpALeft = b.comparePoint(a.leftSE.point)\n      if (bCmpALeft !== 0) return bCmpALeft\n\n      // is the B right endpoint colinear to segment A?\n      const aCmpBRight = a.comparePoint(b.rightSE.point)\n      if (aCmpBRight < 0) return 1\n      if (aCmpBRight > 0) return -1\n\n      // colinear segments, consider the one with left-more\n      // left endpoint to be first (arbitrary?)\n      return 1\n    }\n\n    // if we get here, the two left endpoints are in the same\n    // vertical plane, ie alx === blx\n\n    // consider the lower left-endpoint to come first\n    if (aly < bly) return -1\n    if (aly > bly) return 1\n\n    // left endpoints are identical\n    // check for colinearity by using the left-more right endpoint\n\n    // is the A right endpoint more left-more?\n    if (arx < brx) {\n      const bCmpARight = b.comparePoint(a.rightSE.point)\n      if (bCmpARight !== 0) return bCmpARight\n\n      // colinear segments with matching left endpoints,\n      // consider the one with more left-more right endpoint to be first\n      return -1\n    }\n\n    // is the B right endpoint more left-more?\n    if (arx > brx) {\n      const aCmpBRight = a.comparePoint(b.rightSE.point)\n      if (aCmpBRight < 0) return 1\n      if (aCmpBRight > 0) return -1\n\n      // colinear segments with matching left endpoints,\n      // consider the one with more left-more right endpoint to be first\n      return 1\n    }\n\n    // if we get here, two two right endpoints are in the same\n    // vertical plane, ie arx === brx\n\n    // consider the lower right-endpoint to come first\n    if (ary < bry) return -1\n    if (ary > bry) return 1\n\n    // right endpoints identical as well, so the segments are idential\n    // fall back on creation order as consistent tie-breaker\n    if (a.id < b.id) return -1\n    if (a.id > b.id) return 1\n\n    // identical segment, ie a === b\n    return 0\n  }\n\n  /* Warning: a reference to ringsIn input will be stored,\n   *  and possibly will be later modified */\n  constructor (leftSE, rightSE, ringsIn) {\n    this.id = ++segmentId\n    this.leftSE = leftSE\n    leftSE.segment = this\n    leftSE.otherSE = rightSE\n    this.rightSE = rightSE\n    rightSE.segment = this\n    rightSE.otherSE = leftSE\n    this.ringsIn = ringsIn\n    this._cache = {}\n    // left unset for performance, set later in algorithm\n    // this.ringOut, this.consumedBy, this.prev\n  }\n\n  static fromRing(pt1, pt2, ring) {\n    let leftPt, rightPt\n\n    // ordering the two points according to sweep line ordering\n    const cmpPts = SweepEvent.comparePoints(pt1, pt2)\n    if (cmpPts < 0) {\n      leftPt = pt1\n      rightPt = pt2\n    }\n    else if (cmpPts > 0) {\n      leftPt = pt2\n      rightPt = pt1\n    }\n    else throw new Error(\n      `Tried to create degenerate segment at [${pt1.x}, ${pt1.y}]`\n    )\n\n    const leftSE = new SweepEvent(leftPt, true)\n    const rightSE = new SweepEvent(rightPt, false)\n    return new Segment(leftSE, rightSE, [ring])\n  }\n\n  /* When a segment is split, the rightSE is replaced with a new sweep event */\n  replaceRightSE (newRightSE) {\n    this.rightSE = newRightSE\n    this.rightSE.segment = this\n    this.rightSE.otherSE = this.leftSE\n    this.leftSE.otherSE = this.rightSE\n  }\n\n  bbox () {\n    const y1 = this.leftSE.point.y\n    const y2 = this.rightSE.point.y\n    return {\n      ll: { x: this.leftSE.point.x, y: y1 < y2 ? y1 : y2 },\n      ur: { x: this.rightSE.point.x, y: y1 > y2 ? y1 : y2 }\n    }\n  }\n\n  /* A vector from the left point to the right */\n  vector () {\n    return {\n      x: this.rightSE.point.x - this.leftSE.point.x,\n      y: this.rightSE.point.y - this.leftSE.point.y\n    }\n  }\n\n  isAnEndpoint (pt) {\n    return (\n      (pt.x === this.leftSE.point.x && pt.y === this.leftSE.point.y) ||\n      (pt.x === this.rightSE.point.x && pt.y === this.rightSE.point.y)\n    )\n  }\n\n  /* Compare this segment with a point. Return value indicates:\n   *     1: point lies above or to the left of segment\n   *     0: point is colinear to segment\n   *    -1: point is below or to the right of segment */\n  comparePoint (point) {\n    if (this.isAnEndpoint(point)) return 0\n    const interPt = closestPoint(this.leftSE.point, this.rightSE.point, point)\n\n    if (point.y < interPt.y) return -1\n    if (point.y > interPt.y) return 1\n\n    // depending on if our segment angles up or down,\n    // the x coord comparison means oppposite things\n    if (point.x < interPt.x) {\n      if (this.leftSE.point.y < this.rightSE.point.y) return 1\n      if (this.leftSE.point.y > this.rightSE.point.y) return -1\n    }\n    if (point.x > interPt.x) {\n      if (this.leftSE.point.y < this.rightSE.point.y) return -1\n      if (this.leftSE.point.y > this.rightSE.point.y) return 1\n    }\n\n    // on the line\n    return 0\n  }\n\n  /* Does the point in question touch the given segment?\n   * Greedy - essentially a 2 * Number.EPSILON comparison.\n   * If it's not possible to add an independent point between the\n   * point and the segment, we say the point 'touches' the segment. */\n  touches (point) {\n    if (!touchesBbox(this.bbox(), point)) return false\n    // if the points have been linked already, performance boost use that\n    if (point === this.leftSE.point || point === this.rightSE.point) return true\n    // avoid doing vector math on tiny vectors\n    if (touchPoints(this.leftSE.point, point)) return true\n    if (touchPoints(this.rightSE.point, point)) return true\n    const cPt1 = closestPoint(this.leftSE.point, this.rightSE.point, point)\n    const avgPt1 = { x: (cPt1.x + point.x) / 2, y: (cPt1.y + point.y) / 2 }\n    return touchPoints(avgPt1, cPt1) || touchPoints(avgPt1, point)\n  }\n\n  /**\n   * Given another segment, returns the first non-trivial intersection\n   * between the two segments (in terms of sweep line ordering), if it exists.\n   *\n   * A 'non-trivial' intersection is one that will cause one or both of the\n   * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:\n   *\n   *   * endpoint of segA with endpoint of segB --> trivial\n   *   * endpoint of segA with point along segB --> non-trivial\n   *   * endpoint of segB with point along segA --> non-trivial\n   *   * point along segA with point along segB --> non-trivial\n   *\n   * If no non-trivial intersection exists, return null\n   * Else, return null.\n   */\n  getIntersection (other) {\n    // If bboxes don't overlap, there can't be any intersections\n    const bboxOverlap = getBboxOverlap(this.bbox(), other.bbox())\n    if (bboxOverlap === null) return null\n\n    // We first check to see if the endpoints can be considered intersections.\n    // This will 'snap' intersections to endpoints if possible, and will\n    // handle cases of colinearity.\n\n    // does each endpoint touch the other segment?\n    const touchesOtherLSE = this.touches(other.leftSE.point)\n    const touchesThisLSE = other.touches(this.leftSE.point)\n    const touchesOtherRSE = this.touches(other.rightSE.point)\n    const touchesThisRSE = other.touches(this.rightSE.point)\n\n    // do left endpoints match?\n    if (touchesThisLSE && touchesOtherLSE) {\n      // these two cases are for colinear segments with matching left\n      // endpoints, and one segment being longer than the other\n      if (touchesThisRSE && !touchesOtherRSE) return this.rightSE.point\n      if (!touchesThisRSE && touchesOtherRSE) return other.rightSE.point\n      // either the two segments match exactly (two trival intersections)\n      // or just on their left endpoint (one trivial intersection\n      return null\n    }\n\n    // does this left endpoint matches (other doesn't)\n    if (touchesThisLSE) {\n      // check for segments that just intersect on opposing endpoints\n      if (touchesOtherRSE && touchPoints(this.leftSE.point, other.rightSE.point)) return null\n      // t-intersection on left endpoint\n      return this.leftSE.point\n    }\n\n    // does other left endpoint matches (this doesn't)\n    if (touchesOtherLSE) {\n      // check for segments that just intersect on opposing endpoints\n      if (touchesThisRSE && touchPoints(this.rightSE.point, other.leftSE.point)) return null\n      // t-intersection on left endpoint\n      return other.leftSE.point\n    }\n\n    // trivial intersection on right endpoints\n    if (touchesThisRSE && touchesOtherRSE) return null\n\n    // t-intersections on just one right endpoint\n    if (touchesThisRSE) return this.rightSE.point\n    if (touchesOtherRSE) return other.rightSE.point\n\n    // None of our endpoints intersect. Look for a general intersection between\n    // infinite lines laid over the segments\n    const pt = intersection(this.leftSE.point, this.vector(), other.leftSE.point, other.vector())\n\n    // are the segments parrallel? Note that if they were colinear with overlap,\n    // they would have an endpoint intersection and that case was already handled above\n    if (pt === null) return null\n\n    // is the intersection found between the lines not on the segments?\n    if (!isInBbox(bboxOverlap, pt)) return null\n\n    // round the the computed point if needed\n    return rounder.round(pt.x, pt.y)\n  }\n\n  /**\n   * Split the given segment into multiple segments on the given points.\n   *  * Each existing segment will retain its leftSE and a new rightSE will be\n   *    generated for it.\n   *  * A new segment will be generated which will adopt the original segment's\n   *    rightSE, and a new leftSE will be generated for it.\n   *  * If there are more than two points given to split on, new segments\n   *    in the middle will be generated with new leftSE and rightSE's.\n   *  * An array of the newly generated SweepEvents will be returned.\n   *\n   * Warning: input array of points is modified\n   */\n  split (point) {\n    const newEvents = []\n    const alreadyLinked = point.events !== undefined\n\n    const newLeftSE = new SweepEvent(point, true)\n    const newRightSE = new SweepEvent(point, false)\n    const oldRightSE = this.rightSE\n    this.replaceRightSE(newRightSE)\n    newEvents.push(newRightSE)\n    newEvents.push(newLeftSE)\n    new Segment(newLeftSE, oldRightSE, this.ringsIn.slice())\n\n    // in the point we just used to create new sweep events with was already\n    // linked to other events, we need to check if either of the affected\n    // segments should be consumed\n    if (alreadyLinked) {\n      newLeftSE.checkForConsuming()\n      newRightSE.checkForConsuming()\n    }\n\n    return newEvents\n  }\n\n  /* Consume another segment. We take their ringsIn under our wing\n   * and mark them as consumed. Use for perfectly overlapping segments */\n  consume (other) {\n    let consumer = this\n    let consumee = other\n    while (consumer.consumedBy) consumer = consumer.consumedBy\n    while (consumee.consumedBy) consumee = consumee.consumedBy\n\n    const cmp = Segment.compare(consumer, consumee)\n    if (cmp === 0) return  // already consumed\n    // the winner of the consumption is the earlier segment\n    // according to sweep line ordering\n    if (cmp  > 0) {\n      const tmp = consumer\n      consumer = consumee\n      consumee = tmp\n    }\n\n    // make sure a segment doesn't consume it's prev\n    if (consumer.prev === consumee) {\n      const tmp = consumer\n      consumer = consumee\n      consumee = tmp\n    }\n\n    for (let i = 0, iMax = consumee.ringsIn.length; i < iMax; i++) {\n      consumer.ringsIn.push(consumee.ringsIn[i])\n    }\n    consumee.ringsIn = null\n    consumee.consumedBy = consumer\n\n    // mark sweep events consumed as to maintain ordering in sweep event queue\n    consumee.leftSE.consumedBy = consumer.leftSE\n    consumee.rightSE.consumedBy = consumer.rightSE\n  }\n\n  /* The first segment previous segment chain that is in the result */\n  prevInResult () {\n    const key = 'prevInResult'\n    if (this._cache[key] === undefined) this._cache[key] = this[`_${key}`]()\n    return this._cache[key]\n  }\n\n  _prevInResult () {\n    if (! this.prev) return null\n    if (this.prev.isInResult()) return this.prev\n    return this.prev.prevInResult()\n  }\n\n  ringsBefore () {\n    const key = 'ringsBefore'\n    if (this._cache[key] === undefined) this._cache[key] = this[`_${key}`]()\n    return this._cache[key]\n  }\n\n  _ringsBefore () {\n    if (! this.prev) return []\n    return (this.prev.consumedBy || this.prev).ringsAfter()\n  }\n\n  ringsAfter () {\n    const key = 'ringsAfter'\n    if (this._cache[key] === undefined) this._cache[key] = this[`_${key}`]()\n    return this._cache[key]\n  }\n\n  _ringsAfter () {\n    const rings = this.ringsBefore().slice(0)\n    for (let i = 0, iMax = this.ringsIn.length; i < iMax; i++) {\n      const ring = this.ringsIn[i]\n      const index = rings.indexOf(ring)\n      if (index === -1) rings.push(ring)\n      else rings.splice(index, 1)\n    }\n    return rings\n  }\n\n  multiPolysBefore () {\n    const key = 'multiPolysBefore'\n    if (this._cache[key] === undefined) this._cache[key] = this[`_${key}`]()\n    return this._cache[key]\n  }\n\n  _multiPolysBefore () {\n    if (! this.prev) return []\n    return (this.prev.consumedBy || this.prev).multiPolysAfter()\n  }\n\n  multiPolysAfter () {\n    const key = 'multiPolysAfter'\n    if (this._cache[key] === undefined) this._cache[key] = this[`_${key}`]()\n    return this._cache[key]\n  }\n\n  _multiPolysAfter () {\n    // first calcualte our polysAfter\n    const polysAfter = []\n    const polysExclude = []\n    const ringsAfter = this.ringsAfter()\n    for (let i = 0, iMax = ringsAfter.length; i < iMax; i++) {\n      const ring = ringsAfter[i]\n      const poly = ring.poly\n      if (polysExclude.indexOf(poly) !== -1) continue\n      if (ring.isExterior) polysAfter.push(poly)\n      else {\n        if (polysExclude.indexOf(poly) === -1) polysExclude.push(poly)\n        const index = polysAfter.indexOf(ring.poly)\n        if (index !== -1) polysAfter.splice(index, 1)\n      }\n    }\n    // now calculate our multiPolysAfter\n    const mps = []\n    for (let i = 0, iMax = polysAfter.length; i < iMax; i++) {\n      const mp = polysAfter[i].multiPoly\n      if (mps.indexOf(mp) === -1) mps.push(mp)\n    }\n    return mps\n  }\n\n  /* Is this segment part of the final result? */\n  isInResult () {\n    const key = 'isInResult'\n    if (this._cache[key] === undefined) this._cache[key] = this[`_${key}`]()\n    return this._cache[key]\n  }\n\n  _isInResult () {\n    // if we've been consumed, we're not in the result\n    if (this.consumedBy) return false\n\n    const mpsBefore = this.multiPolysBefore()\n    const mpsAfter = this.multiPolysAfter()\n\n    switch (operation.type) {\n      case 'union': {\n        // UNION - included iff:\n        //  * On one side of us there is 0 poly interiors AND\n        //  * On the other side there is 1 or more.\n        const noBefores = mpsBefore.length === 0\n        const noAfters = mpsAfter.length === 0\n        return noBefores !== noAfters\n      }\n\n      case 'intersection': {\n        // INTERSECTION - included iff:\n        //  * on one side of us all multipolys are rep. with poly interiors AND\n        //  * on the other side of us, not all multipolys are repsented\n        //    with poly interiors\n        let least\n        let most\n        if (mpsBefore.length < mpsAfter.length) {\n          least = mpsBefore.length\n          most = mpsAfter.length\n        } else {\n          least = mpsAfter.length\n          most = mpsBefore.length\n        }\n        return most === operation.numMultiPolys && least < most\n      }\n\n      case 'xor': {\n        // XOR - included iff:\n        //  * the difference between the number of multipolys represented\n        //    with poly interiors on our two sides is an odd number\n        const diff = Math.abs(mpsBefore.length - mpsAfter.length)\n        return diff % 2 === 1\n      }\n\n      case 'difference': {\n        // DIFFERENCE included iff:\n        //  * on exactly one side, we have just the subject\n        const isJustSubject = mps => mps.length === 1 && mps[0].isSubject\n        return isJustSubject(mpsBefore) !== isJustSubject(mpsAfter)\n      }\n\n      default:\n        throw new Error(`Unrecognized operation type found ${operation.type}`)\n    }\n  }\n\n}\n","import { touch } from './flp'\n\n/**\n * A bounding box has the format:\n *\n *  { ll: { x: xmin, y: ymin }, ur: { x: xmax, y: ymax } }\n *\n */\n\nexport const isInBbox = (bbox, point) => {\n  return (\n    (bbox.ll.x <= point.x) &&\n    (point.x <= bbox.ur.x) &&\n    (bbox.ll.y <= point.y) &&\n    (point.y <= bbox.ur.y)\n  )\n}\n\n/* Greedy comparison with a bbox. A point is defined to 'touch'\n * a bbox if:\n *  - it is inside the bbox\n *  - it 'touches' one of the sides (another greedy comparison) */\nexport const touchesBbox = (bbox, point) => {\n  return (\n    ((bbox.ll.x <= point.x) || touch(bbox.ll.x, point.x)) &&\n    ((point.x <= bbox.ur.x) || touch(point.x, bbox.ur.x)) &&\n    ((bbox.ll.y <= point.y) || touch(bbox.ll.y, point.y)) &&\n    ((point.y <= bbox.ur.y) || touch(point.y, bbox.ur.y))\n  )\n}\n\n/* Returns either null, or a bbox (aka an ordered pair of points)\n * If there is only one point of overlap, a bbox with identical points\n * will be returned */\nexport const getBboxOverlap = (b1, b2) => {\n  // check if the bboxes overlap at all\n  if (\n    b2.ur.x < b1.ll.x ||\n    b1.ur.x < b2.ll.x ||\n    b2.ur.y < b1.ll.y ||\n    b1.ur.y < b2.ll.y\n  ) return null\n\n  // find the middle two X values\n  const lowerX = b1.ll.x < b2.ll.x ? b2.ll.x : b1.ll.x\n  const upperX = b1.ur.x < b2.ur.x ? b1.ur.x : b2.ur.x\n\n  // find the middle two Y values\n  const lowerY = b1.ll.y < b2.ll.y ? b2.ll.y : b1.ll.y\n  const upperY = b1.ur.y < b2.ur.y ? b1.ur.y : b2.ur.y\n\n  // put those middle values together to get the overlap\n  return { ll: { x: lowerX, y: lowerY }, ur: { x: upperX, y: upperY } }\n}\n","import Segment from './segment'\n\nexport class RingIn {\n  constructor (geomRing, poly, isExterior) {\n    this.poly = poly\n    this.isExterior = isExterior\n    this.segments = []\n\n    let prevPoint = geomRing[0]\n    for (let i = 1, iMax = geomRing.length; i < iMax; i++) {\n      let point = geomRing[i]\n      this.segments.push(Segment.fromRing(prevPoint, point, this))\n      prevPoint = point\n    }\n    this.segments.push(Segment.fromRing(prevPoint, geomRing[0], this))\n  }\n\n  getSweepEvents () {\n    const sweepEvents = []\n    for (let i = 0, iMax = this.segments.length; i < iMax; i++) {\n      const segment = this.segments[i]\n      sweepEvents.push(segment.leftSE)\n      sweepEvents.push(segment.rightSE)\n    }\n    return sweepEvents\n  }\n}\n\nexport class PolyIn {\n  constructor (geomPoly, multiPoly) {\n    this.exteriorRing = new RingIn(geomPoly[0], this, true)\n    this.interiorRings = []\n    for (let i = 1, iMax = geomPoly.length; i < iMax; i++) {\n      this.interiorRings.push(new RingIn(geomPoly[i], this, false))\n    }\n    this.multiPoly = multiPoly\n  }\n\n  getSweepEvents () {\n    const sweepEvents = this.exteriorRing.getSweepEvents()\n    for (let i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n      const ringSweepEvents = this.interiorRings[i].getSweepEvents()\n      for (let j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {\n        sweepEvents.push(ringSweepEvents[j])\n      }\n    }\n    return sweepEvents\n  }\n}\n\nexport class MultiPolyIn {\n  constructor (geomMultiPoly) {\n    this.polys = []\n    for (let i = 0, iMax = geomMultiPoly.length; i < iMax; i++) {\n      this.polys.push(new PolyIn(geomMultiPoly[i], this))\n    }\n    this.isSubject = false\n  }\n\n  markAsSubject () {\n    this.isSubject = true\n  }\n\n  getSweepEvents () {\n    const sweepEvents = []\n    for (let i = 0, iMax = this.polys.length; i < iMax; i++) {\n      const polySweepEvents = this.polys[i].getSweepEvents()\n      for (let j = 0, jMax = polySweepEvents.length; j < jMax; j++) {\n        sweepEvents.push(polySweepEvents[j])\n      }\n    }\n    return sweepEvents\n  }\n}\n","import { compareVectorAngles } from './vector'\nimport SweepEvent from './sweep-event'\n\nexport class RingOut {\n  /* Given the segments from the sweep line pass, compute & return a series\n   * of closed rings from all the segments marked to be part of the result */\n  static factory (allSegments) {\n    const ringsOut = []\n\n    for (let i = 0, iMax = allSegments.length; i < iMax; i++) {\n      const segment = allSegments[i]\n      if (!segment.isInResult() || segment.ringOut) continue\n\n      let prevEvent = null\n      let event = segment.leftSE\n      let nextEvent = segment.rightSE\n      const events = [event]\n\n      const startingPoint = event.point\n      const intersectionLEs = []\n\n      /* Walk the chain of linked events to form a closed ring */\n      while (true) {\n        prevEvent = event\n        event = nextEvent\n        events.push(event)\n\n        /* Is the ring complete? */\n        if (event.point === startingPoint) break\n\n        while (true) {\n          const availableLEs = event.getAvailableLinkedEvents()\n\n          /* Did we hit a dead end? This shouldn't happen. Indicates some earlier\n           * part of the algorithm malfunctioned... please file a bug report. */\n          if (availableLEs.length === 0) {\n            const firstPt = events[0].point\n            const lastPt = events[events.length - 1].point\n            throw new Error(\n              `Unable to complete output ring starting at [${firstPt.x},` +\n                ` ${firstPt.y}]. Last matching segment found ends at` +\n                ` [${lastPt.x}, ${lastPt.y}].`\n            )\n          }\n\n          /* Only one way to go, so cotinue on the path */\n          if (availableLEs.length === 1) {\n            nextEvent = availableLEs[0].otherSE\n            break\n          }\n\n          /* We must have an intersection. Check for a completed loop */\n          let indexLE = null\n          for (let j = 0, jMax = intersectionLEs.length; j < jMax; j++) {\n            if (intersectionLEs[j].point === event.point) {\n              indexLE = j\n              break\n            }\n          }\n          /* Found a completed loop. Cut that off and make a ring */\n          if (indexLE !== null) {\n            const intersectionLE = intersectionLEs.splice(indexLE)[0]\n            const ringEvents = events.splice(intersectionLE.index)\n            ringEvents.unshift(ringEvents[0].otherSE)\n            ringsOut.push(new RingOut(ringEvents.reverse()))\n            continue\n          }\n          /* register the intersection */\n          intersectionLEs.push({\n            index: events.length,\n            point: event.point,\n          })\n          /* Choose the left-most option to continue the walk */\n          const comparator = event.getLeftmostComparator(prevEvent)\n          nextEvent = availableLEs.sort(comparator)[0].otherSE\n          break\n        }\n      }\n\n      ringsOut.push(new RingOut(events))\n    }\n    return ringsOut\n  }\n\n  constructor (events) {\n    this.events = events\n    for (let i = 0, iMax = events.length; i < iMax; i++) {\n      events[i].segment.ringOut = this\n    }\n    this.poly = null\n  }\n\n  getGeom () {\n    // Remove superfluous points (ie extra points along a straight line),\n    let prevPt = this.events[0].point\n    const points = [prevPt]\n    for (let i = 1, iMax = this.events.length - 1; i < iMax; i++) {\n      const pt = this.events[i].point\n      const nextPt = this.events[i + 1].point\n      if (compareVectorAngles(pt, prevPt, nextPt) === 0) continue\n      points.push(pt)\n      prevPt = pt\n    }\n\n    // ring was all (within rounding error of angle calc) colinear points\n    if (points.length === 1) return null\n\n    // check if the starting point is necessary\n    const pt = points[0]\n    const nextPt = points[1]\n    if (compareVectorAngles(pt, prevPt, nextPt) === 0) points.shift()\n\n    points.push(points[0])\n    const step = this.isExteriorRing() ? 1 : -1\n    const iStart = this.isExteriorRing() ? 0 : points.length - 1\n    const iEnd = this.isExteriorRing() ? points.length : -1\n    const orderedPoints = []\n    for (let i = iStart; i != iEnd; i += step) orderedPoints.push([points[i].x, points[i].y])\n    return orderedPoints\n  }\n\n  isExteriorRing () {\n    if (this._isExteriorRing === undefined) {\n      const enclosing = this.enclosingRing()\n      this._isExteriorRing = enclosing ? ! enclosing.isExteriorRing() : true\n    }\n    return this._isExteriorRing\n  }\n\n  enclosingRing () {\n    if (this._enclosingRing === undefined) {\n      this._enclosingRing = this._calcEnclosingRing()\n    }\n    return this._enclosingRing\n  }\n\n  /* Returns the ring that encloses this one, if any */\n  _calcEnclosingRing () {\n    // start with the ealier sweep line event so that the prevSeg\n    // chain doesn't lead us inside of a loop of ours\n    let leftMostEvt = this.events[0]\n    for (let i = 1, iMax = this.events.length; i < iMax; i++) {\n      const evt = this.events[i]\n      if (SweepEvent.compare(leftMostEvt, evt) > 0) leftMostEvt = evt\n    }\n\n    let prevSeg = leftMostEvt.segment.prevInResult()\n    let prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null\n\n    while (true) {\n      // no segment found, thus no ring can enclose us\n      if (!prevSeg) return null\n\n      // no segments below prev segment found, thus the ring of the prev\n      // segment must loop back around and enclose us\n      if (!prevPrevSeg) return prevSeg.ringOut\n\n      // if the two segments are of different rings, the ring of the prev\n      // segment must either loop around us or the ring of the prev prev\n      // seg, which would make us and the ring of the prev peers\n      if (prevPrevSeg.ringOut !== prevSeg.ringOut) {\n        if (prevPrevSeg.ringOut.enclosingRing() !== prevSeg.ringOut) {\n          return prevSeg.ringOut\n        } else return prevSeg.ringOut.enclosingRing()\n      }\n\n      // two segments are from the same ring, so this was a penisula\n      // of that ring. iterate downward, keep searching\n      prevSeg = prevPrevSeg.prevInResult()\n      prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null\n    }\n  }\n}\n\nexport class PolyOut {\n  constructor (exteriorRing) {\n    this.exteriorRing = exteriorRing\n    exteriorRing.poly = this\n    this.interiorRings = []\n  }\n\n  addInterior (ring) {\n    this.interiorRings.push(ring)\n    ring.poly = this\n  }\n\n  getGeom () {\n    const geom = [this.exteriorRing.getGeom()]\n    // exterior ring was all (within rounding error of angle calc) colinear points\n    if (geom[0] === null) return null\n    for (let i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n      const ringGeom = this.interiorRings[i].getGeom()\n      // interior ring was all (within rounding error of angle calc) colinear points\n      if (ringGeom === null) continue\n      geom.push(ringGeom)\n    }\n    return geom\n  }\n}\n\nexport class MultiPolyOut {\n  constructor (rings) {\n    this.rings = rings\n    this.polys = this._composePolys(rings)\n  }\n\n  getGeom () {\n    const geom = []\n    for (let i = 0, iMax = this.polys.length; i < iMax; i++) {\n      const polyGeom = this.polys[i].getGeom()\n      // exterior ring was all (within rounding error of angle calc) colinear points\n      if (polyGeom === null) continue\n      geom.push(polyGeom)\n    }\n    return geom\n  }\n\n  _composePolys (rings) {\n    const polys = []\n    for (let i = 0, iMax = rings.length; i < iMax; i++) {\n      const ring = rings[i]\n      if (ring.poly) continue\n      if (ring.isExteriorRing()) polys.push(new PolyOut(ring))\n      else {\n        const enclosingRing = ring.enclosingRing()\n        if (!enclosingRing.poly) polys.push(new PolyOut(enclosingRing))\n        enclosingRing.poly.addInterior(ring)\n      }\n    }\n    return polys\n  }\n}\n","import SplayTree from 'splaytree'\nimport Segment from './segment'\nimport SweepEvent from './sweep-event'\n\n/**\n * NOTE:  We must be careful not to change any segments while\n *        they are in the SplayTree. AFAIK, there's no way to tell\n *        the tree to rebalance itself - thus before splitting\n *        a segment that's in the tree, we remove it from the tree,\n *        do the split, then re-insert it. (Even though splitting a\n *        segment *shouldn't* change its correct position in the\n *        sweep line tree, the reality is because of rounding errors,\n *        it sometimes does.)\n */\n\nexport default class SweepLine {\n  constructor (queue, comparator = Segment.compare) {\n    this.queue = queue\n    this.tree = new SplayTree(comparator)\n    this.segments = []\n  }\n\n  process (event) {\n    const segment = event.segment\n    const newEvents = []\n\n    // if we've already been consumed by another segment,\n    // clean up our body parts and get out\n    if (event.consumedBy) {\n      if (event.isLeft) this.queue.remove(event.otherSE)\n      else this.tree.remove(segment)\n      return newEvents\n    }\n\n    const node = event.isLeft\n      ? this.tree.insert(segment)\n      : this.tree.find(segment)\n\n    if (! node) throw new Error(\n      `Unable to find segment #${segment.id} ` +\n      `[${segment.leftSE.point.x}, ${segment.leftSE.point.y}] -> ` +\n      `[${segment.rightSE.point.x}, ${segment.rightSE.point.y}] ` +\n      'in SweepLine tree. Please submit a bug report.'\n    )\n\n    let prevNode = node\n    let nextNode = node\n    let prevSeg = undefined\n    let nextSeg = undefined\n\n    // skip consumed segments still in tree\n    while (prevSeg === undefined) {\n      prevNode = this.tree.prev(prevNode)\n      if (prevNode === null) prevSeg = null\n      else if (prevNode.key.consumedBy === undefined) prevSeg = prevNode.key\n    }\n\n    // skip consumed segments still in tree\n    while (nextSeg === undefined) {\n      nextNode = this.tree.next(nextNode)\n      if (nextNode === null) nextSeg = null\n      else if (nextNode.key.consumedBy === undefined) nextSeg = nextNode.key\n    }\n\n    if (event.isLeft) {\n\n      // Check for intersections against the previous segment in the sweep line\n      let prevMySplitter = null\n      if (prevSeg) {\n        const prevInter = prevSeg.getIntersection(segment)\n        if (prevInter !== null) {\n          if (!segment.isAnEndpoint(prevInter)) prevMySplitter = prevInter\n          if (!prevSeg.isAnEndpoint(prevInter)) {\n            const newEventsFromSplit = this._splitSafely(prevSeg, prevInter)\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i])\n            }\n          }\n        }\n      }\n\n      // Check for intersections against the next segment in the sweep line\n      let nextMySplitter = null\n      if (nextSeg) {\n        const nextInter = nextSeg.getIntersection(segment)\n        if (nextInter !== null) {\n          if (!segment.isAnEndpoint(nextInter)) nextMySplitter = nextInter\n          if (!nextSeg.isAnEndpoint(nextInter))  {\n            const newEventsFromSplit = this._splitSafely(nextSeg, nextInter)\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i])\n            }\n          }\n        }\n      }\n\n      // For simplicity, even if we find more than one intersection we only\n      // spilt on the 'earliest' (sweep-line style) of the intersections.\n      // The other intersection will be handled in a future process().\n      if (prevMySplitter !== null || nextMySplitter !== null) {\n\n        let mySplitter = null\n        if (prevMySplitter === null) mySplitter = nextMySplitter\n        else if (nextMySplitter === null) mySplitter = prevMySplitter\n        else {\n          const cmpSplitters = SweepEvent.comparePoints(prevMySplitter, nextMySplitter)\n          if (cmpSplitters < 0) mySplitter = prevMySplitter\n          if (cmpSplitters > 0) mySplitter = nextMySplitter\n          // the two splitters are the exact same point\n          mySplitter = prevMySplitter\n        }\n\n        // Rounding errors can cause changes in ordering,\n        // so remove afected segments and right sweep events before splitting\n        this.queue.remove(segment.rightSE)\n        newEvents.push(segment.rightSE)\n\n        const newEventsFromSplit = segment.split(mySplitter)\n        for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n          newEvents.push(newEventsFromSplit[i])\n        }\n      }\n\n      if (newEvents.length > 0) {\n        // We found some intersections, so re-do the current event to\n        // make sure sweep line ordering is totally consistent for later\n        // use with the segment 'prev' pointers\n        this.tree.remove(segment)\n        newEvents.push(event)\n\n      } else {\n        // done with left event\n        this.segments.push(segment)\n        segment.prev = prevSeg\n      }\n\n    } else {\n      // event.isRight\n\n      // since we're about to be removed from the sweep line, check for\n      // intersections between our previous and next segments\n      if (prevSeg && nextSeg) {\n        const inter = prevSeg.getIntersection(nextSeg)\n        if (inter !== null) {\n          if (!prevSeg.isAnEndpoint(inter))  {\n            const newEventsFromSplit = this._splitSafely(prevSeg, inter)\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i])\n            }\n          }\n          if (!nextSeg.isAnEndpoint(inter))  {\n            const newEventsFromSplit = this._splitSafely(nextSeg, inter)\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i])\n            }\n          }\n        }\n      }\n\n      this.tree.remove(segment)\n    }\n\n    return newEvents\n  }\n\n  /* Safely split a segment that is currently in the datastructures\n   * IE - a segment other than the one that is currently being processed. */\n  _splitSafely(seg, pt) {\n    // Rounding errors can cause changes in ordering,\n    // so remove afected segments and right sweep events before splitting\n    // removeNode() doesn't work, so have re-find the seg\n    // https://github.com/w8r/splay-tree/pull/5\n    this.tree.remove(seg)\n    const rightSE = seg.rightSE\n    this.queue.remove(rightSE)\n    const newEvents = seg.split(pt)\n    newEvents.push(rightSE)\n    // splitting can trigger consumption\n    if (seg.consumedBy === undefined) this.tree.insert(seg)\n    return newEvents\n  }\n}\n","import SplayTree from 'splaytree'\nimport * as cleanInput from './clean-input'\nimport * as geomIn from './geom-in'\nimport * as geomOut from './geom-out'\nimport rounder from './rounder'\nimport SweepEvent from './sweep-event'\nimport SweepLine from './sweep-line'\n\nexport class Operation {\n  run (type, geom, moreGeoms) {\n    operation.type = type\n    rounder.reset()\n\n    /* Make a copy of the input geometry with rounded points as objects */\n    const geoms = [cleanInput.pointsAsObjects(geom)]\n    for (let i = 0, iMax = moreGeoms.length; i < iMax; i++) {\n      geoms.push(cleanInput.pointsAsObjects(moreGeoms[i]))\n    }\n\n    /* Clean inputs */\n    for (let i = 0, iMax = geoms.length; i < iMax; i++) {\n      cleanInput.forceMultiPoly(geoms[i])\n      cleanInput.cleanMultiPoly(geoms[i])\n    }\n\n    /* Convert inputs to MultiPoly objects, mark subject */\n    const multipolys = []\n    for (let i = 0, iMax = geoms.length; i < iMax; i++) {\n      multipolys.push(new geomIn.MultiPolyIn(geoms[i]))\n    }\n    multipolys[0].markAsSubject()\n    operation.numMultiPolys = multipolys.length\n\n    /* Put segment endpoints in a priority queue */\n    const queue = new SplayTree(SweepEvent.compare)\n    for (let i = 0, iMax = multipolys.length; i < iMax; i++) {\n      const sweepEvents = multipolys[i].getSweepEvents()\n      for (let j = 0, jMax = sweepEvents.length; j < jMax; j++) {\n        queue.insert(sweepEvents[j])\n      }\n    }\n\n    /* Pass the sweep line over those endpoints */\n    const sweepLine = new SweepLine(queue)\n    let prevQueueSize = queue.size\n    let node = queue.pop()\n    while (node) {\n      const evt = node.key\n      if (queue.size === prevQueueSize) {\n        // prevents an infinite loop, an otherwise common manifestation of bugs\n        throw new Error(\n          `Unable to pop() SweepEvent [${evt.point.x}, ${evt.point.y}] from ` +\n          `segment #${evt.segment.id} from queue. Please file a bug report.`\n        )\n      }\n      const newEvents = sweepLine.process(evt)\n      for (let i = 0, iMax = newEvents.length; i < iMax; i++) {\n        const evt = newEvents[i]\n        if (evt.consumedBy === undefined) queue.insert(evt)\n      }\n      prevQueueSize = queue.size\n      node = queue.pop()\n    }\n\n    // free some memory we don't need anymore\n    rounder.reset()\n\n    /* Collect and compile segments we're keeping into a multipolygon */\n    const ringsOut = geomOut.RingOut.factory(sweepLine.segments)\n    const result = new geomOut.MultiPolyOut(ringsOut)\n    return result.getGeom()\n  }\n}\n\n// singleton available by import\nconst operation = new Operation()\n\nexport default operation\n","import operation from './operation'\n\nconst union = (geom, ...moreGeoms) =>\n  operation.run('union', geom, moreGeoms)\n\nconst intersection = (geom, ...moreGeoms) =>\n  operation.run('intersection', geom, moreGeoms)\n\nconst xor = (geom, ...moreGeoms) =>\n  operation.run('xor', geom, moreGeoms)\n\nconst difference = (subjectGeom, ...clippingGeoms) =>\n  operation.run('difference', subjectGeom, clippingGeoms)\n\nexport default {\n  union: union,\n  intersection: intersection,\n  xor: xor,\n  difference: difference,\n}\n"],"names":["Node","_createClass","key","data","_classCallCheck","this","left","right","DEFAULT_COMPARE","a","b","splay","i","t","comparator","l","r","y","N","cmp","insert","tree","node","_size","remove","x","split","v","Tree","arguments","length","undefined","_comparator","_root","value","add","current","compare","visitor","ctx","Q","done","push","pop","call","low","high","fn","keys","forEach","_ref","values","_ref2","minNode","maxNode","index","d","root","successor","predecessor","head","next","p","toList","presort","size","sort","pivot","j","tmp","loadRecursive","parent","start","end","middle","Math","floor","mergedList","l1","l2","p1","p2","mergeLists","createList","sortedListToBST","list","get","printNode","n","out","printRow","prefix","isTail","concat","indent","join","newKey","newData","_split2","merge","epsilon","Number","EPSILON","pow","EPSILON_SQ","touch","m","touchPoints","aPt","bPt","mx","my","aYMiss","crossProduct","dotProduct","compareVectorAngles","basePt","endPt1","endPt2","v1","v2","kross","sqrt","cosineOfAngle","pShared","pBase","pAngle","vBase","vAngle","closestPoint","ptA1","ptA2","ptB","nearPt","farPt","vA","vB","dist","horizontalIntersection","pt","verticalIntersection","PtRounder","reset","xRounder","CoordRounder","yRounder","round","SplayTree","coord","prevNode","prev","nextNode","rounder","pointsAsObjects","geom","output","Array","isArray","Error","iMax","jMax","k","kMax","forceMultiPoly","unshift","splice","cleanMultiPoly","multipoly","poly","exteriorRing","cleanRing","interiorRing","ring","ringLengthBeforeTheClean","firstPt","lastPt","prevPt","nextPt","isPointUncessary","SweepEvent","point","isLeft","events","other","otherEvents","evt","checkForConsuming","numEvents","evt1","segment","consumedBy","evt2","otherSE","consume","ringOut","isInResult","baseEvent","_this","cache","Map","fillCache","linkedEvent","nextEvent","set","sine","cosine","has","_cache$get","asine","acosine","_cache$get2","bsine","bcosine","ptCmp","comparePoints","link","Segment","segmentId","leftSE","rightSE","ringsIn","id","_cache","newRightSE","y1","y2","ll","ur","isAnEndpoint","interPt","bbox","touchesBbox","cPt1","avgPt1","bboxOverlap","b1","b2","lowerX","upperX","getBboxOverlap","touchesOtherLSE","touches","touchesThisLSE","touchesOtherRSE","touchesThisRSE","pt1","pt2","ve","d1","d2","intersection","vector","newEvents","alreadyLinked","newLeftSE","oldRightSE","replaceRightSE","slice","consumer","consumee","prevInResult","ringsAfter","rings","ringsBefore","indexOf","multiPolysAfter","polysAfter","polysExclude","isExterior","mps","mp","multiPoly","mpsBefore","multiPolysBefore","mpsAfter","operation","type","least","most","numMultiPolys","abs","isJustSubject","isSubject","alx","blx","arx","brx","aly","bly","ary","bry","aCmpBLeft","comparePoint","bCmpARight","bCmpALeft","aCmpBRight","leftPt","rightPt","cmpPts","RingIn","geomRing","segments","prevPoint","fromRing","sweepEvents","PolyIn","geomPoly","interiorRings","getSweepEvents","ringSweepEvents","MultiPolyIn","geomMultiPoly","polys","polySweepEvents","RingOut","points","shift","step","isExteriorRing","iStart","iEnd","orderedPoints","_isExteriorRing","enclosing","enclosingRing","_enclosingRing","_calcEnclosingRing","leftMostEvt","prevSeg","prevPrevSeg","allSegments","ringsOut","prevEvent","event","startingPoint","intersectionLEs","availableLEs","getAvailableLinkedEvents","indexLE","getLeftmostComparator","intersectionLE","ringEvents","reverse","PolyOut","getGeom","ringGeom","MultiPolyOut","_composePolys","polyGeom","addInterior","SweepLine","queue","find","nextSeg","prevMySplitter","prevInter","getIntersection","newEventsFromSplit","_splitSafely","nextMySplitter","nextInter","mySplitter","cmpSplitters","inter","seg","Operation","moreGeoms","geoms","cleanInput","multipolys","geomIn","markAsSubject","sweepLine","prevQueueSize","process","geomOut","factory","union","_len","_key","run","_len2","_key2","xor","_len3","_key3","difference","subjectGeom","_len4","clippingGeoms","_key4"],"mappings":"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"}